{"version":3,"file":"orgy.devel.js","sources":["../src/js/main.js","../src/js/deferred.js","../src/js/queue.js","../src/js/cast.js","../src/js/build.js"],"names":["public","private","list","modules_exported","modules_loaded","registered_callbacks","debug_mode","i","export","obj","push","define","id","data","settled","def","deferred","resolve","debug","export_module","then","process","module","exports","value","modules","assign","tgt","arr","add","q","this","model","remove","queue","register_callback","name","fn","array_to_function","target","clone","slice","root_id","splice","root","hasOwnProperty","window","console","error","x","y","l","length","args","end","Array","parent","b","key","constructor","naive_cloner","donors","o","a","JSON","parse","stringify","msg","force_debug_mode","options","_o","factory","activate","tpl","done_fired","_state","_timeout_id","error_q","then_q","done_fn","reject_q","downstream","execution_history","overwritable","timeout","remote","resolver_fired","resolver","v","call","set","log","clearTimeout","_set_state","reject","err","unshift","catch_params","apply","arguments","rejector","r","done","int","_signal_downstream","_get_state","_make_id","autonamed","auto_timeout","type","scope","setTimeout","auto_timeout_cb","msgs","search_obj_recursively","cb","receive_signal","propName","breadcrumb","r1","indexOf","convert_to_promise","url","split","pop","search","join","prom","_wrap_event","promise","warn","_wrap_timer","_wrap_xhr","document","$","ready","load","on","_start","Date","getTime","_end","start","elapsed","dep","required","attach_xhr","load_script","m","__dependencies","__id","__resolver","rol","head","getElementsByTagName","documentElement","node","createElement","setAttribute","onload","onreadystatechange","appendChild","onerror","req","XMLHttpRequest","open","show_messages","setRequestHeader","return_packet","readyState","status","responseText","e","send","process_result","request","require","get","response","body","statusCode","path","substring","cwd","fs","readFile","exit","deps","upgrade","halt_resolution","upstream","dependencies","reset","check_self","from_id","values","cast","Orgy"],"mappings":"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","sourcesContent":["var public = {};\nvar private = {};\n\n\n////////////////////////////////////////\n//  PUBLIC VARIABLES\n////////////////////////////////////////\n\n\n/**\n * A directory of all promises, deferreds, and queues.\n * @type object\n */\npublic.list = {};\n\n\n/**\n * Array of all exported modules\n * @type Array\n */\npublic.modules_exported = [];\n\n\n/**\n * Index number of last module loaded in public.modules_exported\n * @type Number\n */\npublic.modules_loaded = 0;\n\n\n/** \n * Callbacks that are run on every resolved item\n * \n */\npublic.registered_callbacks = {};\n\n\n/**\n * Debugging mode\n * @type Number\n */\npublic.debug_mode = 1;\n\n\n/**\n * iterator for ids\n * @type integer\n */\npublic.i = 0;\n\n\n////////////////////////////////////////\n//  PUBLIC METHODS\n////////////////////////////////////////\n\n\npublic.export = function(obj){\n    \n    public.modules_exported.push(obj);\n    return obj;\n}\n\n\n/**\n* Creates a new promise from a value and an id and automatically resolves it.\n* \n* @param {string} id\n* @param {mixed} data\n* @returns {object} resolved promise\n*/\npublic.define = function(id,data){\n\n   //ALLOW OVERWRITING OF UNSETTLED PROMISES\n   //GOOD FOR WHEN A FILE IS NOT RESOLVED-ON-LOAD \n   if(!public.list[id] || public.list[id].settled !== 1){\n       \n       //GET DEFERRED\n       var def = public.deferred({\n           id : id\n       });\n\n       //SETTLE \n       def.resolve(data);\n       \n       return def;\n   }\n   else{\n       public.debug(\"Can't define \"+id + \". Already resolved.\");\n   }\n\n};\n\n\n/**\n * Exports the value of a resolved promise to module.exports if node,\n * window.modules[deferred.id] if browser.\n * \n * @param {object} deferred\n * @returns void\n */\npublic.export_module = function(deferred){\n    \n    deferred.then(function(){\n\n        if(typeof process === 'object' && process + '' === '[object process]'){\n            //DEFINE IN NODE\n            module.exports = deferred.value;\n        }\n        else{\n            //DEFINE IN BROWSER\n            modules[deferred.id] = deferred.value;\n        }\n        \n    });\n    \n}\n\n\n/**\n * Add/remove an upstream dependency to/from a queue. \n * \n * Can use a queue id, even for a queue that is yet to be created.\n * \n * @param {string} tgt | queue / queue id\n * @param {array}  arr | list/promise ids,dependencies\n * @param {boolean} add | add if true, remove if false\n * \n * @return {array} queue of list\n */\npublic.assign = function(tgt,arr,add){\n\n    add = (typeof add === \"boolean\") ? add : 1;\n\n    var id,q;\n    switch(true){\n        case(typeof tgt === 'object' && typeof tgt.then === 'function'):\n            id = tgt.id;\n            break;\n        case(typeof tgt === 'string'):\n            id = tgt;\n            break;\n        default:\n            return public.debug(\"Assign target must be a queue object or the id of a queue.\");\n    }\n\n    //IF TARGET ALREADY LISTED\n    if(this.list[id] && this.list[id].model === 'queue'){\n        q = this.list[id];\n        \n        //=> ADD TO QUEUE'S UPSTREAM\n        if(add){\n            q.add(arr);\n        }\n        //=> REMOVE FROM QUEUE'S UPSTREAM\n        else{\n            q.remove(arr);\n        }\n    }\n    //CREATE NEW QUEUE AND ADD DEPENDENCIES\n    else if(add){\n\n        q = public.queue(arr,{\n            id : id\n        });\n    }\n    //ERROR: CAN'T REMOVE FROM A QUEUE THAT DOES NOT EXIST\n    else{\n        public.debug(\"Cannot remove dependencies from a queue that does not exist.\");\n    }\n\n    return q;\n};\n\n\npublic.register_callback = function(name,fn){\n    public.registered_callbacks[name] = fn;\n};\n\n    \n/**\n * Converts a specially formatted array into a function.\n * \n * \n * @param {type} target\n * @returns {object}\n */\npublic.array_to_function = function(target){\n\n    //CLONE TARGET\n    var clone = target.slice(0);\n\n    var root_id = clone[0];\n    clone.splice(0,1);\n\n    var root;\n    if(public.list[root_id] && public.list[root_id].hasOwnProperty(\"value\")){\n        root = public.list[root_id].value; \n    }\n    else{\n        root = window[root_id];\n    }\n\n\n    if(typeof root === 'undefined'){\n        console.error(root_id + \" not found on window or public.list\");\n        debugger;\n    }\n\n\n    var x,y;\n    x = y = root;\n\n    //REMOVE LAST ARRAY ELEMENT (ARGS)\n    var l = clone.length;\n    var args = clone[l-1];\n\n    //POINTER TO A FUNCTION WILL HAVE AN ARRAY AS LAST ELEMENT\n    var end;\n    if(args instanceof Array){\n        end = l - 1;\n    }\n    //POINTER TO AN ARRAY WILL NOT\n    else{\n        end = l;\n    }\n\n    var parent;\n    for(var b=0; b < end; b++){\n        var key = clone[b];\n\n        if(b === end - 1 || l === 1){\n           parent = x; \n        }\n\n        if(typeof x[key] === 'undefined'){\n            console.error(\"Property '\"+key+\"' not found on object:\", x);\n            debugger;\n            return;\n        }\n        x = x[key];\n        y = x;\n    }    \n\n    return {\n        constructor : x\n        ,args : args\n        ,parent : parent\n    };\n}\n\n\n/**\n * Makes a shallow copy of an array. \n * Makes a copy of an object so long as it is JSON\n * \n * @param {array} array of donor objects, overwritten from right to left\n * @returns {object}\n */\npublic.naive_cloner = function(donors){\n    var o = {};\n    for(var a in donors){\n        for(var b in donors[a]){\n            if(donors[a][b] instanceof Array){\n                o[b] = donors[a][b].slice(0);\n            }\n            else if(typeof donors[a][b] === 'object'){\n                o[b] = JSON.parse(JSON.stringify(donors[a][b]));\n            }\n            else{\n                o[b] = donors[a][b];\n            }\n        }\n    }\n    return o;\n}\n        \n\n/**\n * Debugging method.\n * \n * @param {string|array} msg\n * @param {boolean} force_debug_mode   Forces debugger when set to true. \n * @returns {Boolean}\n */\npublic.debug = function(msg,force_debug_mode){\n    if(msg instanceof Array){\n        for(var i in msg){\n            console.error(\"ERROR: \"+msg[i]);\n        }\n    }\n    else{\n        console.error(\"ERROR: \"+msg);\n    }\n    if(public.debug_mode == 1 || force_debug_mode){\n        debugger;\n    }\n    return false;\n}\n","public.deferred = function(options){\n    \n    if(!options || typeof options.id !== 'string'){\n        return public.debug(\"Must set id.\");\n    }\n    \n    if(!public.list[options.id]){\n        //CREATE NEW INSTANCE OF DEFERRED CLASS\n        var _o = private.deferred.factory(options);\n\n        //ACTIVATE DEFERRED\n        _o = private.deferred.activate(_o);\n    }\n    else{\n        _o = public.list[options.id];\n    }\n    \n    return _o;\n};\n\n\n\nprivate.deferred = {\n    \n    factory : function(options){\n        \n        var _o = public.naive_cloner([\n            private.deferred.tpl\n            ,options\n        ]);\n\n        //YOU NOW HAVE A DEFERRED OBJECT THAT IS INACTIVE ON THE WAITLIST\n        return _o;\n    }\n    \n    \n    ,tpl : {\n        \n        model : \"deferred\"\n\n        //A COUNTER FOR AUT0-GENERATED PROMISE ID'S\n        ,settled : 0 \n        ,id : null\n        ,done_fired : 0\n\n        /**\n         * STATE CODES:\n         * ------------------\n         * -1   => SETTLING [EXECUTING CALLBACKS]\n         *  0   => PENDING\n         *  1   => RESOLVED / FULFILLED\n         *  2   => REJECTED \n         */\n        ,_state : 0\n        ,_timeout_id : null\n        ,value : []\n\n        ,error_q : []  \n        ,then_q : []\n        ,done_fn : null\n        ,reject_q : []\n\n        //PROMISE HAS OBSERVERS BUT DOES NOT OBSERVE OTHERS\n        ,downstream : {}\n        ,execution_history : []\n        ,overwritable : 0   //WHEN TRUE, ALLOWS RE-INIT [FOR UPGRADES TO A QUEUE]          \n        ,timeout : 5000\n\n        /**\n         * REMOTE\n         * \n         * REMOTE == 1  =>  [DEFAULT] Make http request for file\n         * \n         * REMOTE == 0  =>  Read file directly from the filesystem\n         * \n         * ONLY APPLIES TO SCRIPTS RUN UNDER NODE AS BROWSER HAS NO \n         * FILESYSTEM ACCESS\n         */\n        ,remote : 1\n\n        //ADDS TO MASTER LIST. ALWAYS DO THIS UNLESS UPGRADING A PROMISE TO A QUEUE\n        ,list : 1   \n\n        ,resolve : function(value){\n\n            if(this.settled !== 0){\n                public.debug(this.id + \" can't resolve. Only unsettled promise objects resolvable.\");\n            }\n\n            //SET STATE TO SETTLEMENT IN PROGRESS\n            this._state = -1; \n\n            //SET VALUE\n            this.value  = value;\n\n            //RUN RESOLVER BEFORE PROCEEDING\n            //EVEN IF THERE IS NO RESOLVER, SET IT TO FIRED WHEN CALLED\n            if(!this.resolver_fired){\n\n                this.resolver_fired = 1;\n\n                //FIRE THE RESOLVER IF SET\n                if(this.resolver){\n                    this.resolver(this,value);\n                    return this;\n                }\n\n            }\n\n            //Allows .then chain to be held up by new async events created as the chain executes.\n            var v,fn,l=this.then_q.length;\n            for(var i = 0; i<l; i++){     \n\n                //REMOVE fn FROM THEN QUEUE. \n                //WHEN A PROMISE OBJ IS RETURNED, AND EXECUTION STOPPED WE\n                //DONT WANT TO REPEAAT A CALL TO SAME fn\n                fn = this.then_q.splice(0,1);\n\n                //CALL fn WITH PRECEDING RESULT OR IF NONE EXISTS, RESOLVER VALUE\n                v = fn[0].call(this, v || this.value);\n                \n                //SAVE fn TO EXECUTION HISTORY\n                this.execution_history.push(fn[0]);\n\n                //IF fn RETURNED AN UNSETTLED PROMISE\n                //WAIT FOR IT TO RESOLVE BEFORE PROCEEDING\n                //AND ADD THE RESULT TO THE END OF VALUE ARRAY\n                if(typeof v !== 'undefined' && v.then){\n                    \n                    //SET THE STATE BACK TO WAITING\n                    this._state = 0;\n                    \n                    //ADD IT TO QUEUE'S UPSTREAM\n                    this.add([v]);\n                    \n                    //END RESOLUTION ATTEMPT AND WAIT FOR v TO RESOLVE\n                    return;\n                }\n                //IF V RETURNED A VALUE MAKE IT THE NEW QUEUE VALUE\n                else if(typeof v !== 'undefined'){\n                    this.value = v;\n                }\n            }\n                        \n            //SET RETURN VALUE TO A GIVEN OBJECT PROPERTY\n            if(this.set){\n                //ARRAY IS TRANSORMED INTO A PATH TO POINT TO\n                if(this.set instanceof Array){\n                    //@todo make property of private to avoid external dependency\n                    var tgt = public.array_to_function(this.set);\n                    tgt.parent[tgt.args] = this.value;\n                }\n                //OTHErWISE ASSUMED TO BE AN OBJECT PROPERTY\n                else if (typeof this.set === 'function'){\n                    this.set(this.value);\n                }\n            }\n\n            //EXECUTE ANY GLOBALLY REGISTERED CALLBACKS\n            for (var i in public.registered_callbacks){\n                console.log(\"Orgy.js executing registered callback '\"+i+\"' on \" + this.id);\n                public.registered_callbacks[i].call(this);\n            }\n           \n            //REMOVE AUTO TIMEOUT TIMER\n            if(this._timeout_id){\n                clearTimeout(this._timeout_id);\n            }\n\n            //SET STATE TO RESOLVED\n            private.deferred._set_state.call(this,1);\n\n            if(this.done_fn !== null){\n                this.done_fired = 1;\n                this.done_fn.call(this,this.value); \n            }\n                \n            return this;\n        }\n\n        ,reject : function(err){\n            \n            if(!(err instanceof Array)){\n                err = [err]\n            }\n            \n            err.unshift(\"REJECTED \"+this.model+\": '\"+this.id+\"'\");\n\n            public.debug(err);\n\n            //REMOVE AUTO TIMEOUT TIMER\n            if(this._timeout_id){\n                clearTimeout(this._timeout_id);\n            }\n\n            //SAVE ERROR OBJECT TO MEMORY FOR USE IN CATCH CALLBACK\n            this.catch_params = err;\n\n            //SET STATE TO REJECTED\n            private.deferred._set_state.call(this,2);\n\n            //EXECUTE REJECTION QUEUE\n            for(var i in this.reject_q){\n                this.value.push(this.reject_q[i].apply(this,arguments));\n            }\n\n            return this;\n        }\n\n        ,then : function(fn,rejector){\n\n            switch(true){\n\n                //ERROR WAS PREVIOUSLY THROWN\n                case(this._state === 2):\n                    break;\n\n                case(this.done_fired === 1):\n                    public.debug(this.id+\" can't attach .then() after .done() has fired.\");\n                    break;\n\n                case(this.settled === 1 && this._state === 1 && !this.done_fired):\n                    var r = fn.call(this,this.value);\n                    if(typeof r !== 'undefined'){\n                        this.value = r;\n                    }\n                    break;\n\n                default:\n\n                    //PUSH CALLBACK TO THEN QUEUE\n                    this.then_q.push(fn);\n\n                    //PUSH REJECT CALLBACK TO REJECTION QUEUE\n                    if(typeof rejector === 'function'){\n                        this.reject_q.push(rejector);\n                    }\n                    break;\n            }\n\n            return this;\n        }\n        \n        ,done : function(fn){\n            \n            if(this.done_fn === null){\n                this.done_fn = fn\n            }\n            else{\n                public.debug(\"done() can only be called once.\");\n            }\n        }\n\n    }\n\n    \n    ///////////////////////////////////////////////////\n    //  METHODS\n    ///////////////////////////////////////////////////\n    \n    \n    /**\n     * \n     * @param {type} int\n     * @returns {undefined}\n     */\n    ,_set_state : function(int){\n\n        this._state = int;\n\n        //IF RESOLVED OR REJECTED, SETTLE\n        if(int === 1 || int === 2){\n            this.settled = 1;\n        }\n\n        private.deferred._signal_downstream.call(this,this);\n    }\n    \n    \n    ,_get_state : function(){\n        return this._state;\n    }\n\n\n    ,activate : function(obj){\n\n        //SET ID\n        if(!obj.id){\n            obj.id = private.deferred._make_id(obj.model);\n            obj.autonamed = true;\n        }\n\n        //MAKE SURE NAMING CONFLICT DOES NOT EXIST\n        if(public.list[obj.id] && !public.list[obj.id].overwritable){\n            public.debug(\"Tried to overwrite \"+obj.id+\" without overwrite permissions.\");\n            return public.list[obj.id];\n        }\n        else{\n            //SAVE TO MASTER LIST\n            public.list[obj.id] = obj;\n        }\n\n        //AUTO TIMEOUT\n        private.deferred.auto_timeout.call(obj);\n\n        return obj;\n    }\n\n\n    /**\n     * Sets the automatic timeout on a promise object.\n     * \n     * @param {integer} optional. timeout\n     * @returns {Boolean}\n     */\n    ,auto_timeout : function(timeout){\n\n        this.timeout = (typeof timeout === 'undefined') ? this.timeout : timeout;\n\n        //AUTO REJECT ON timeout\n        if(!this.type || this.type !== 'timer'){\n\n            //DELETE PREVIOUS TIMEOUT IF EXISTS\n            if(this._timeout_id){\n                clearTimeout(this._timeout_id);\n            }\n\n            if(typeof this.timeout === 'undefined'){\n                public.debug(this.id+\" Auto timeout this.timeout cannot be undefined.\");\n            }\n            else if (this.timeout === -1){\n                //NO AUTO TIMEOUT SET\n                return false;\n            }\n            var scope = this;\n\n            this._timeout_id = setTimeout(function(){\n                private.deferred.auto_timeout_cb.call(scope);\n            }, this.timeout);\n        }\n        else{\n            //@todo WHEN A TIMER, ADD DURATION TO ALL UPSTREAM AND LATERAL?\n        }\n        return true;\n    }\n\n\n    /**\n     * Callback for autotimeout. Declaration here avoids memory leak.\n     * \n     * @param {type} exp\n     * @returns {undefined}\n     */\n    ,auto_timeout_cb : function(){\n        \n        if(this._state !== 1){\n\n            //GET THE UPSTREAM ERROR ID\n            var msgs = [];\n            var scope = this;\n\n            var fn = function(obj){\n                if(obj._state !== 1){\n                    return obj.id\n                }\n                else{\n                    return false;\n                }\n            };\n\n            /**\n             * Run over a given object property recursively, applying callback until \n             * callback returns a non-false value.\n             */\n            var r = private.deferred.search_obj_recursively(this,'upstream',fn);\n            msgs.push(scope.id + \": rejected by auto timeout after \" + this.timeout + \"ms\");\n            msgs.push(\"Cause:\");\n            msgs.push(r);\n            return private.deferred.tpl.reject.call(this,msgs);\n            \n        }\n    }\n\n\n    ,error : function(cb){\n\n        //IF ERROR ALREADY THROWN, EXECUTE CB IMMEDIATELY\n        if(this._state === 2){\n            cb();\n        }\n        else{\n            this.error_q.push(cb);\n        }\n\n        return this;\n    }\n\n\n    ,_make_id : function(model){\n        return \"anonymous-\" + model + \"-\" + (public.i++);\n    }\n\n\n    /**\n     * Signals all downstream promises that private promise object's state has changed.\n     * \n     * \n     * @todo Since the same queue may have been assigned twice directly or \n     * indirectly via shared dependencies, make sure not to double resolve\n     * - which throws an error.\n     *     \n     * @returns {void}\n     */\n    ,_signal_downstream : function(target){\n\n        //MAKE SURE ALL DOWNSTREAM IS UNSETTLED\n        for(var i in target.downstream){\n            if(target.downstream[i].settled === 1){\n                public.debug(target.id + \" tried to settle promise \"+\"'\"+target.downstream[i].id+\"' that has already been settled.\");\n            }\n        }\n\n        //NOW THAT WE KNOW ALL DOWNSTREAM IS UNSETTLED, WE CAN IGNORE ANY\n        //SETTLED THAT RESULT AS A SIDE EFFECT TO ANOTHER SETTLEMENT\n        for (var i in target.downstream){\n            if(target.downstream[i].settled !== 1){\n                private.queue.receive_signal(target.downstream[i],target.id);\n            }\n        }\n    }\n    \n    \n    /**\n    * Run over a given object property recursively, applying callback until \n    * callback returns a non-false value.\n    * \n    * @param {object} obj      \n    * @param {string} propName          The property name of the array to bubble up\n    * @param {function} fn              The test callback to be applied to each object\n    * @param {array} breadcrumb         The breadcrumb through the chain of the first match\n    * @returns {mixed}\n    */\n    ,search_obj_recursively : function(obj,propName,fn,breadcrumb){\n      \n        if(typeof breadcrumb === 'undefined'){\n            breadcrumb = [obj.id];\n        }\n      \n        var r1;\n\n//debugger;\n        \n        for(var i in obj[propName]){\n\n            //RUN TEST\n            r1 = fn(obj[propName][i]);\n            \n            if(r1 !== false){\n            //MATCH RETURNED. RECURSE INTO MATCH IF HAS PROPERTY OF SAME NAME TO SEARCH\n                //CHECK THAT WE AREN'T CAUGHT IN A CIRCULAR LOOP\n                if(breadcrumb.indexOf(r1) !== -1){\n                    return public.debug([\n                        \"Circular condition in recursive search of obj property '\"\n                            +propName+\"'. Offending value: \"+r1\n                        ,breadcrumb\n                    ]);\n                }\n                \n                breadcrumb.push(r1);\n\n                if(obj[propName][i][propName]){\n                    return private.deferred.search_obj_recursively(obj[propName][i],propName,fn,breadcrumb);\n                }\n                \n                break;\n            }\n\n        }\n\n        return breadcrumb;\n    }\n    \n    \n    /**\n     * Converts a promise description into a promise.\n     * \n     * @param {type} obj\n     * @returns {undefined}\n     */\n    ,convert_to_promise : function(obj){\n \n        //IF ALREADY EXISTS, RETURN EXISTING\n        if(!obj.id){\n            if(obj.type === 'timer'){\n                obj.id = \"timer-\" + obj.timeout + \"-\"+public.i++;\n            }\n            else if(typeof obj.url === 'string'){\n                obj.id = obj.url.split(\"/\").pop();\n                //REMOVE .js FROM ID\n                if(obj.id.search(\".js\")!== -1){\n                    obj.id = obj.id.split(\".\");\n                    obj.id.pop();\n                    obj.id = obj.id.join(\".\");\n                }\n            }\n            else{\n                console.error(\"Dependency type \"+obj.type+\" requires id, but id undefined.\",obj);\n                debugger;\n                return false;\n            }\n        }\n\n        if(obj.type !== 'timer'){\n            //RETURN THE PROMISE IF IT ALREADY EXISTS\n            if(typeof public.list[obj.id] !== 'undefined'){\n                return public.list[obj.id];\n            }\n        }\n\n        //CONVERT DEPENDENCY TO PROMISE\n        var prom;\n        switch(true){\n\n            //EVENT\n            case(obj.type === 'event'):\n                prom = private.deferred._wrap_event(obj);\n                break;\n\n            //ALREADY A PROMISE\n            case(obj.type === 'promise' || obj.then):   \n\n                switch(true){\n                    \n                    //OBJECT PROPERTY .promise EXPECTED TO RETURN A PROMISE\n                    case(typeof obj.promise === 'function'):\n                        if(obj.scope){\n                            prom = obj.promise.call(obj.scope);\n                        }\n                        else{\n                            prom = obj.promise();\n                        }\n                        break;\n                        \n                    //OBJECT IS A PROMISE\n                    case(obj.then):\n                        prom = obj;\n                        break;\n                    \n                    //OBJECT IS A REFERENCE TO A PROMISE\n                    case(typeof obj.id === 'string'):\n                        //GET EXISTING\n                        if(public.list[obj.id]){\n                            prom = public.list[obj.id];\n                        }\n                        //CREATE DEFERRED\n                        else{\n                            console.warn(\"Promise '\"+obj.id +\"': did not exist. Auto creating new deferred.\");\n                            prom = public.deferred({\n                                id : obj.id\n                            });\n                        };\n                        break;\n                        \n                    default:\n                        \n                }\n\n                //MAKE SURE IS PROMISE\n                if(typeof prom !== 'object' || !prom.then){\n                    console.error(\"Dependency labeled as a promise did not return a promise.\");\n                    console.error(obj);\n                    debugger;\n                    return false;\n                }\n                break;\n\n            case(obj.type === 'timer'):\n                prom = private.deferred._wrap_timer(obj);\n                break;\n\n            //XHR\n            default:\n                obj.type = obj.type || \"default\";\n                prom = private.deferred._wrap_xhr(obj);\n        }\n        \n        //INDEX PROMISE BY ID FOR FUTURE REFERENCING\n        public.list[obj.id] = prom;\n\n        return prom;\n    }\n    \n    \n    /**\n     * Converts a reference to a DOM event to a promise.\n     * Resolved on first event trigger.\n     * \n     * @todo remove jquery dependency\n     * \n     * @param {object} obj\n     * @returns {object} deferred object\n     */\n    ,_wrap_event : function(obj){\n\n        var def = public.deferred({\n            id : obj.id\n        });\n        \n        var resolver = function(){\n            private.deferred.tpl.resolve.call(def,1);\n        };\n\n        //BROWSER\n        if(typeof document !== 'undefined' && typeof window !== 'undefined'){\n            \n            if(typeof $ !== 'function'){\n                var msg = 'window and document based events depend on jQuery';\n                console.error(msg);\n                debugger;\n                def.reject(msg);\n            }\n            else{\n                //For now, depend on jquery for IE8 DOMContentLoaded polyfill\n                switch(true){\n                    case(obj.id === 'ready' || obj.id === 'DOMContentLoaded'):\n                        $(document).ready(resolver);\n                        break;\n                    case(obj.id === 'load'):\n                        $(window).load(resolver);\n                        break;\n                    default:\n                        $(document).on(obj.id,\"body\",resolver);\n                }\n            }\n        }\n\n        return def;\n    }\n    \n\n    ,_wrap_timer : function(obj){\n\n        var prom = public.deferred(obj);\n        \n        (function(prom){\n            \n            var _start = new Date().getTime();      \n            setTimeout(function(){\n                var _end = new Date().getTime();\n                prom.resolve({\n                    start : _start\n                    ,end : _end\n                    ,elapsed : _end - _start\n                    ,timeout : obj.timeout\n                });\n            },obj.timeout);\n            \n        }(prom));\n        \n        return prom;\n    }\n    \n    \n    /**\n     * Creates a deferred object that depends on the loading of a file.\n     * \n     * @param {object} obj\n     * @returns {object} deferred object\n     */\n    ,_wrap_xhr : function(dep){\n        \n        \n        var required = [\"id\",\"url\"];\n        for(var i in required){\n            if(!dep[required[i]]){\n                return public.debug(\"File requests converted to promises require: \" + required[i]);\n            }\n        }\n\n        \n        //IF PROMISE FOR THIS URL ALREADY EXISTS, RETURN IT\n        if(public.list[dep.id]){\n            return public.list[dep.id];\n        }\n        \n\n        //CONVERT TO DEFERRED:\n        var deferred;\n        deferred = public.deferred(dep);\n        deferred = private.deferred.attach_xhr(deferred,dep);\n        return deferred;\n    }\n    \n    \n    ,load_script : function(deferred,data){\n\n        //CHECK IF LAST SCRIPT LOADED RETURNED A MODULE\n        if(public.modules_exported.length > public.modules_loaded){\n            \n            //GET LAST MODULE EXPORTED\n            var m = public.modules_exported[public.modules_exported.length-1];\n\n            //IF RESOLVER EXISTS, LOAD ONCE RESOLVED\n            if(m.__dependencies instanceof Array){\n                \n                //AUTO SET ID PROPERTY ON MODULE\n                m.__id = deferred.id;\n                \n                public.queue(m.__dependencies || [],{\n                    id : m.__id\n                    ,resolver : function(){\n                        m.__resolver.call(m,deferred,deferred.value);\n                    }\n                });\n            }\n            else{\n                //ELSE RESOLVE NOW\n                deferred.resolve(m)\n            }\n\n            //INCREMENT MODULES LOADED\n            public.modules_loaded ++;\n        }\n        else{\n            \n            deferred.resolve(data);\n        }\n        \n    }\n    \n    /**\n     *    \n     * \n     * @param {type} deferred\n     * @param {type} dep\n     * \n     * dep:\n     * =========\n     *                  \n     * <fs> boolean. Filesystem. Whether to loda the file from server filesytem or via http server\n     *                  \n     * @returns {unresolved}\n     */\n    ,attach_xhr : function(deferred,dep){\n\n        //DEFAULT ALL TO RESOLVE-ON-LOAD\n        dep.rol = (typeof dep.rol !== 'undefined') ? dep.rol : 1;\n\n        //BROWSER\n        if(typeof process !== 'object' || process + '' !== '[object process]'){\n            \n            this.head = this.head || document.getElementsByTagName(\"head\")[0] || document.documentElement;\n\n            switch(true){\n\n                case(dep.type==='css' || dep.type==='link'):\n\n                    var node = document.createElement(\"link\");\n                    node.setAttribute(\"href\",dep.url);\n                    node.setAttribute(\"type\",\"text/css\");\n                    node.setAttribute(\"rel\",\"stylesheet\");\n                    (function(){\n                        node.onload = node.onreadystatechange = function(){\n                           deferred.resolve(node);\n                       };\n                    }(node));\n                    this.head.appendChild(node);\n                    break;\n\n                case(dep.type==='script'):\n                    \n                    var node = document.createElement(\"script\");\n                    node.type = 'text/javascript';\n                    node.setAttribute(\"src\",dep.url);\n                    node.setAttribute(\"id\",dep.id);\n                    node.onerror = function(){\n                        deferred.reject(\"Failed to load path: \" + dep.url);\n                    };\n                    \n                    (function(node,dep){\n                        node.onload = node.onreadystatechange = function(){\n                            private.deferred.load_script(deferred,node);\n                        };\n                    }(node,dep))\n                    \n                    //put scripts before <base> elements, after <meta>\n                    this.head.appendChild(node);\n                    break;\n\n                case(dep.type==='json'):\n                default:\n                    \n                    var r;\n                    var req = new XMLHttpRequest();\n                    req.open('GET', dep.url, true);\n\n                    if(typeof dep.show_messages !== 'undefined'){\n                        req.setRequestHeader('show-messages', dep.show_messages);\n                    }\n                    if(typeof dep.return_packet !== 'undefined'){\n                        req.setRequestHeader('return-packet', dep.return_packet);\n                    }\n\n                    req.onreadystatechange = function() {\n                        if (req.readyState === 4) {\n                            if(req.status === 200){\n                                r = req.responseText;\n                                if(dep.type === 'json'){\n                                    try{\n                                        r = JSON.parse(r);\n                                    }\n                                    catch(e){\n                                        public.debug([\"Could not decode JSON\",dep.url,r]);\n\n                                    }\n                                }\n                                deferred.resolve(r);\n                            }\n                            else{\n                                deferred.reject(\"Error loading \"+dep.url);\n                            }\n                        }\n                    };\n                    req.send(null);\n            }\n        }\n        //NODEJS\n        else{\n\n            function process_result(deferred,data,dep){\n\n                switch(true){\n\n                    case(dep.type==='script'):\n                        private.deferred.load_script(deferred,data);\n                        break;\n\n                    case(dep.type === 'json'):\n                        data = JSON.parse(data);\n                        deferred.resolve(data);\n                        break;\n                        \n                    case(dep.type==='css' || dep.type==='link'):\n                    default:\n                        deferred.resolve(data);\n                }\n            }\n            \n            \n            if(dep.remote){\n                var request = require('request');\n                request.get(dep.url, function (error, response, body) {\n                    if (!error && response.statusCode == 200) {\n                        process_result(deferred,body,dep);\n                    }\n                });\n\n            }\n            else{\n                \n                //PREPEND PATH WITH CURRENT WORKING DIRECTORY OF PROCESS\n                var path = dep.url;\n\n                //REMOVE ANY RELATIVE PATH CHARACTERS \n                //AS LONG AS PATH DOES NOT START WITH *\n                //WHICH INDICATES ABSOLUTE PATH\n                while (path.substring(0, 1) === \".\"\n                || path.substring(0, 1) === \"/\") {\n                    path = path.substring(1);\n                }\n                \n                var cwd = process.cwd();\n                path = cwd + '/' + path;\n\n                //DON'T GET SCRIPTS AS TEXT\n                if(dep.type === 'script'){\n                    var data = require(path);\n                    private.deferred.load_script(deferred,data);\n                }\n                else{\n                    \n                    var fs = require('fs');\n\n                    (function(deferred,dep){\n                        \n                        fs.readFile(path, 'utf8', function (err, data) {\n\n                            if (err){\n                                public.debug(\"File \" + dep.url + \" not found @ local path '\" + path +\"'\");\n                                process.exit();\n                            }\n\n                            process_result(deferred,data,dep);\n                        });\n\n                    }(deferred,dep));\n                    \n                }\n                \n            }\n\n        }\n        \n        return deferred;\n    }\n};","public.queue = function(deps,options){\n\n    var _o;\n    deps = deps || [];  \n    \n    if(!options || !options.id){\n        public.debug(\"Queues require an id.\");\n    }\n    \n    //DOES NOT ALREADY EXIST\n    if(!public.list[options.id]){\n        \n        //CREATE NEW QUEUE OBJECT\n        var _o = private.queue.factory(options);\n\n        //ACTIVATE QUEUE\n        _o = private.queue.activate(_o,options,deps);\n\n    }\n    //ALREADY EXISTS\n    else {\n        \n        _o = public.list[options.id];\n        \n        if(_o.model !== 'queue'){\n        //MATCH FOUND BUT NOT A QUEUE, UPGRADE TO ONE\n\n            options.overwritable = 1;\n\n            _o = private.queue.upgrade(_o,options,deps);\n        }\n        else{\n            \n            //OVERWRITE ANY EXISTING OPTIONS\n            for(var i in options){\n                _o[i] = options[i];\n            }\n            \n            //ADD ADDITIONAL DEPENDENCIES IF NOT RESOLVED\n            if(deps.length > 0){\n                private.queue.tpl.add.call(_o,deps);\n            }\n            \n        }\n        \n        //RESUME RESOLUTION UNLESS SPECIFIED OTHERWISE\n        _o.halt_resolution = (typeof options.halt_resolution !== 'undefined') ?\n        options.halt_resolution : 0;\n    }\n    \n    return _o;\n};\n\n\nprivate.queue = {\n    \n    \n    factory : function(options){\n\n        //CREATE A NEW QUEUE OBJECT\n        var _o = public.naive_cloner([\n            private.deferred.tpl\n            ,private.queue.tpl\n            ,options\n        ]);\n\n        //YOU NOW HAVE A QUEUE OBJECT THAT IS INACTIVE ON THE WAITLIST\n        return _o;\n    }    \n    \n    \n    /**\n     * Template object for all queues\n     * \n     * @type object\n     */\n    ,tpl : {\n        \n        model : 'queue'\n\n\n        //SET TRUE AFTER RESOLVER FIRED\n        ,resolver_fired : 0\n\n\n        //PREVENTS A QUEUE FROM RESOLVING EVEN IF ALL DEPENDENCIES MET\n        //PURPOSE: PREVENTS QUEUES CREATED BY ASSIGNMENT FROM RESOLVING \n        //BEFORE THEY ARE FORMALLY INSTANTIATED\n        ,halt_resolution : 0\n        \n\n        //USED TO CHECK STATE, ENSURES ONE COPY\n        ,upstream : {}\n        \n        \n        //USED RETURN VALUES, ENSURES ORDER\n        ,dependencies : []\n\n\n        ///////////////////////////////////////////////////\n        //  PUBLIC METHODS\n        ///////////////////////////////////////////////////\n\n\n        /**\n         * Add list of dependencies to a queue's upstream array.\n         * \n         * The queue will resolve once all the promises in its \n         * upstream array are resolved.\n         * \n         * When public.config.debug == 1, method will test each dependency is not\n         * previously scheduled to resolve downstream from the target, in which \n         * case it would never resolve because its upstream depends on it.\n         * \n         * @param {array} array of dependencies to add\n         * @returns {array} upstream\n         */\n        ,add : function(arr){\n\n            try{\n                if(arr.length === 0) return this.upstream;\n            }\n            catch(err){\n                public.debug(err);\n            }\n\n            //IF NOT PENDING, DO NOT ALLOW TO ADD\n            if(this._state !== 0){\n                return public.debug(\"Cannot add list to queue id:'\"+this.id\n                +\"'. Queue settled/in the process of being settled.\");\n            }\n\n            for(var a in arr){\n                \n                switch(true){\n\n                    //CHECK IF ID OF EXISTING PROMISE\n                    case(typeof arr[a] === 'string'):\n                        if(!public.list[arr[a]]){\n                            return public.debug(arr[a]+\"' does not exist so cannot be added to a queue.\");\n                        }\n                        else{\n                            arr[a] = public.list[arr[a]];\n                        }\n                        break;\n\n                    //IF NOT, ATTEMPT TO CONVERT IT TO A PROMISE\n                    case(typeof arr[a] === 'object' && typeof arr[a].then !== 'function'):\n                        arr[a] = private.deferred.convert_to_promise(arr[a]);\n                        break;\n\n                    //REF IS A PROMISE.\n                    case(typeof arr[a].then === 'function'):\n                        break;\n\n                    default:\n                        console.error(\"Object could not be converted to promise.\");\n                        console.error(arr[a]);\n                        debugger;\n                        continue;\n                }\n\n                //must check the target to see if the dependency exists in its downstream\n                for(var b in this.downstream){\n                    if(b === arr[a].id){\n                        return public.debug(\"Error adding upstream dependency '\"+arr[a].id+\"' to queue\"+\" '\"+this.id+\"'.\\n Promise object for '\"+arr[a].id+\"' is scheduled to resolve downstream from queue '\"+this.id+\"' so it can't be added upstream.\");\n                    }\n                }\n\n                //ADD TO UPSTREAM, DOWNSTREAM, DEPENDENCIES\n                this.upstream[arr[a].id] = arr[a];\n                arr[a].downstream[this.id] = this;\n                this.dependencies.push(arr[a]);\n\n            }\n\n            return this.upstream;\n        }\n\n\n        /**\n         * Remove list from a queue.\n         * \n         * @param {array} arr\n         * @returns {array} array of list the queue is upstream\n         */\n        ,remove : function(arr){\n\n            //IF NOT PENDING, DO NOT ALLOW REMOVAL\n            if(this._state !== 0){\n                console.error(\"Cannot remove list from queue id:'\"+this.id+\"'. Queue settled/in the process of being settled.\");\n                return false;\n            }\n\n            for(var a in arr){\n                if(this.upstream[arr[a].id]){\n                    delete this.upstream[arr[a].id];\n                    delete arr[a].downstream[this.id];\n                }\n            }\n        }\n\n\n        /**\n         * Resets an existing,settled queue back to waiting state.\n         * Clears out the downstream.\n         * Fails if not settled.\n         * \n         * @returns {obj}\n         */\n        ,reset : function(options){\n\n            if(this.settled !== 1 || this._state !== 1){\n                public.debug(\"Can only reset a queue settled without errors.\");\n            }\n\n            options = options || {};\n\n            this.settled = 0;\n            this._state = 0; \n            this.resolver_fired = 0;\n            this.done_fired = 0;\n\n            //REMOVE AUTO TIMEOUT TIMER\n            if(this._timeout_id){\n                clearTimeout(this._timeout_id);\n            }\n            \n            //CLEAR OUT THE DOWNSTREAM\n            this.downstream = {};\n            this.dependencies = [];\n\n            //SET NEW AUTO TIMEOUT\n            private.deferred.auto_timeout.call(this,options.timeout);\n\n            //POINTLESS - WILL JUST IMMEDIATELY RESOLVE SELF\n            //this.check_self()\n\n            return this;\n        }\n        \n        \n        /**\n         * Cauaes a queue to look over its dependencies and see if it \n         * can be resolved.\n         * \n         * This is done automatically by each dependency that loads,\n         * so is not needed unless:\n         * \n         * -debugging\n         * \n         * -the queue has been reset and no new\n         * dependencies were since added.\n         * \n         * @returns {int} State of the queue.\n         */\n        ,check_self : function(){\n            private.queue.receive_signal(this,this.id);\n            return this._state;\n        }\n    }\n    \n    \n    ///////////////////////////////////////////////////\n    //  PRIVATE METHODS\n    ///////////////////////////////////////////////////\n    \n    \n    /**\n     * Activates a queue object.\n     * \n     * @param {object} o\n     * @param {object} options\n     * @param {array} deps\n     * @returns {object} queue\n     */\n    ,activate : function(o,options,deps){\n        \n        //ACTIVATE AS A DEFERRED\n        o = private.deferred.activate(o);\n\n        //ADD ANY DEFERREDS TO QUEUE\n        private.queue.tpl.add.call(o,deps);\n\n        //SEE IF CAN BE IMMEDIATELY RESOLVED BY CHECKING UPSTREAM\n        private.queue.receive_signal(o,o.id);\n        \n        //ASSIGN THIS QUEUE UPSTREAM TO OTHER QUEUES\n        if(o.assign){\n            for(var a in o.assign){\n                public.assign(o.assign[a],[o],true);\n            }\n        }\n        \n        return o;\n    }\n    \n    \n    /**\n    * A \"signal\" here causes a queue to look through each item in its upstream and \n    * check to see if all are resolved. \n    * \n    * Signals can only be received by a queue itself or a promise/deferred/queue\n    * in its upstream.\n    * \n    * @param {string} from_id\n    * @returns {void}\n    */\n    ,receive_signal : function(target,from_id){\n\n        if(target.halt_resolution === 1) return;\n\n       //MAKE SURE THE SIGNAL WAS FROM A PROMISE BEING LISTENED TO\n       //BUT ALLOW SELF STATUS CHECK\n       if(from_id !== target.id && !target.upstream[from_id]){\n           console.error(from_id + \" can't signal \" + target.id + \" because not in upstream.\");\n           debugger;\n           return;\n       }\n       //RUN THROUGH QUEUE OF OBSERVING PROMISES TO SEE IF ALL DONE\n       else{\n           var status = 1;\n           for(var i in target.upstream){\n               //SETS STATUS TO 0 IF ANY OBSERVING HAVE FAILED, BUT NOT IF PENDING OR RESOLVED\n               if(target.upstream[i]._state !== 1) {\n                   status = target.upstream[i]._state;\n                   break;\n               }\n           }\n       }\n\n       //RESOLVE QUEUE IF UPSTREAM FINISHED\n       if(status === 1){\n           \n            //GET RETURN VALUES PER DEPENDENCIES, WHICH SAVES ORDER AND \n            //REPORTS DUPLICATES\n            var values = [];\n            for(var i in target.dependencies){\n                values.push(target.dependencies[i].value);\n            }\n\n            private.deferred.tpl.resolve.call(target,values);\n       }\n\n       if(status === 2){\n           var err = [\n               target.id+\" dependency '\"+target.upstream[i].id + \"' was rejected.\"\n               ,target.upstream[i].arguments\n           ];\n           private.deferred.tpl.reject.apply(target,err);\n       }\n    }\n\n\n    /**\n    * Upgrades a promise object to a queue.\n    * \n    * @param {object} prom\n    * @param {object} options\n    * @param {array} dependencies\n    * @returns {object} queue object\n    */\n    ,upgrade : function(obj,options,deps){\n\n        if(obj.settled !== 0 || (obj.model !== 'promise' && obj.model !== 'deferred')){\n            return public.debug('Can only upgrade unsettled promise or deferred into a queue.');\n        }\n        \n       //GET A NEW QUEUE OBJECT AND MERGE IN\n        var _o = public.naive_cloner([\n            private.queue.tpl\n            ,options\n        ]);\n        \n        for(var i in _o){\n           obj[i] = _o[i];\n        }\n        \n        delete _o;\n\n        //CREATE NEW INSTANCE OF QUEUE\n        obj = private.queue.activate(obj,options,deps);\n\n        //RETURN QUEUE OBJECT\n        return obj;\n    }\n    \n};","public.cast = function(obj){\n            \n    var required = [\"then\",\"error\",\"id\"];\n    for(var i in required){\n        if(!obj[required[i]]){\n            return public.debug(\"Castable objects require: \" + required[i]);\n        }\n    }\n\n    //GET A BLANK DEFERRED TO PLAY WITH\n    var deferred = public.deferred({\n        id : obj.id\n    });\n\n    //CREATE RESOLVER [ASYNC]\n    var resolver = function(){\n        deferred.resolve.call(deferred,arguments[0]);\n    };\n\n    //SET RESOLVER\n    obj.then(resolver);\n\n    //CREATE REJECTOR [ASYNC]\n    var err = function(err){\n        deferred.reject(err);\n    };\n\n    //SET REJECTOR\n    obj.error(err);\n\n    //RETURN THE DEFERRED\n    return deferred;\n}\n        ","if(typeof process === 'object' && process + '' === '[object process]'){\n    // is node\n    module.exports = public;\n}\nelse{\n    // not node\n    Orgy = public;\n}"]}