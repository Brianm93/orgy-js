{"version":3,"file":"orgy.devel.js","sources":["?","../src/js/main.js","../src/js/deferred.js","../src/js/queue.js","../src/js/cast.js","../src/js/build.js"],"names":["exports","global","public","private","list","modules_exported","modules_loaded","registered_callbacks","i","config","obj","debug","define","id","data","def","settled","__dependencies","call","__id","queue","__ui","_is_orgy_module","resolver","__resolver","bind","deferred","resolve","assign","tgt","arr","add","q","then","this","model","remove","register_callback","req","array_to_function","target","clone","slice","root_id","splice","root","hasOwnProperty","value","window","console","error","x","y","l","length","args","end","Array","parent","b","key","constructor","naive_cloner","donors","o","a","JSON","parse","stringify","msg","force_debug_mode","debug_mode","mode","process","exit","autopath","document","options","_o","factory","activate","tpl","done_fired","_state","_timeout_id","error_q","then_q","done_fn","reject_q","downstream","execution_history","overwritable","timeout","remote","resolver_fired","hook_before_success","v","fn","push","set","filter","log","clearTimeout","_set_state","done","reject","err","unshift","catch_params","apply","arguments","rejector","r","int","_signal_downstream","_get_state","_make_id","autonamed","auto_timeout","type","scope","setTimeout","auto_timeout_cb","msgs","search_obj_recursively","cb","receive_signal","propName","breadcrumb","r1","indexOf","join","convert_to_promise","url","split","pop","search","prom","_wrap_event","warn","promise","_wrap_timer","_wrap_xhr","$","ready","load","on","_start","Date","getTime","_end","start","elapsed","dep","required","attach_xhr","Orgy","replace","head","getElementsByTagName","documentElement","node","createElement","setAttribute","onload","onreadystatechange","onerror","appendChild","reeject","XMLHttpRequest","open","show_messages","setRequestHeader","return_packet","readyState","status","responseText","e","send","process_result","request","require","get","response","body","statusCode","append","fs","readFile","cwd","deps","upgrade","halt_resolution","upstream","dependencies","reset","check_self","from_id","values","cast","module"],"mappings":";;;;;;;CAAC,SAASA,SAASC;IAASA,OAAO,UAAUD;ICA7C,IAAIE;IACJ,IAAIC;IAYJD,OAAOE;IAOPF,OAAOG;IAOPH,OAAOI,iBAAiB;IAOxBJ,OAAOK;IAOPL,OAAOM,IAAI;IAaXN,OAAOO,SAAS,SAASC;QAErB,IAAGA,KAAI;YACH,KAAI,IAAIF,KAAKE,KAAI;gBACb,WAAUP,QAAQM,OAAOD,OAAO,aAAY;oBACxCL,QAAQM,OAAOD,KAAKE,IAAIF;uBAExB;oBACA,OAAON,OAAOS,MAAM,eAAaH,IAAE;;;;QAM/C,OAAOL,QAAQM;;IAanBP,OAAOU,SAAS,SAASC,IAAGC;QAExB,IAAIC;QAGJ,IAAGb,OAAOE,KAAKS,OAAOX,OAAOE,KAAKS,IAAIG,YAAY,GAAE;YAChD,OAAOd,OAAOS,MAAM,kBAAkBE,KAAK,uBAAsB;;QAGrEC,KAAKG,wBAAyBH,KAAKG,mBAAmB,aAChDH,KAAKG,eAAeC,KAAKJ,QACzBA,KAAKG;QAGX,WAAUH,SAAS,mBAAmBA,KAAKK,SAAS,UAAS;YAEzDJ,MAAMb,OAAOkB,MAAMN,KAAKG;gBACpBJ,IAAKA;gBACJQ,aAAeP,KAAKO,SAAS,cAAeP,KAAKO,OAAO;gBACxDC,iBAAkB;gBAClBC,iBAAmBT,KAAKU,eAAe,aACtCV,KAAKU,WAAWC,KAAKX,QAAQ;;eAGnC;YAGAC,MAAMb,OAAOwB;gBACVb,IAAKA;;YAIRE,IAAIY,QAAQb;;QAIhB,OAAOC;;IAeXb,OAAO0B,SAAS,SAASC,KAAIC,KAAIC;QAE7BA,aAAcA,QAAQ,YAAaA,MAAM;QAEzC,IAAIlB,IAAGmB;QACP,QAAO;UACH,YAAYH,QAAQ,mBAAmBA,IAAII,SAAS;YAChDpB,KAAKgB,IAAIhB;YACT;;UACJ,YAAYgB,QAAQ;YAChBhB,KAAKgB;YACL;;UACJ;YACI,OAAO3B,OAAOS,MAAM;;QAI5B,IAAGuB,KAAK9B,KAAKS,OAAOqB,KAAK9B,KAAKS,IAAIsB,UAAU,SAAQ;YAChDH,IAAIE,KAAK9B,KAAKS;YAGd,IAAGkB,KAAI;gBACHC,EAAED,IAAID;mBAGN;gBACAE,EAAEI,OAAON;;eAIZ,IAAGC,KAAI;YAERC,IAAI9B,OAAOkB,MAAMU;gBACbjB,IAAKA;;eAIT;YACAX,OAAOS,MAAM;;QAGjB,OAAOqB;;IAIX9B,OAAOmC,oBAAoB,SAAS3B;QAEhC,IAAI4B,QAAO,MAAK;QAChB,KAAI,IAAI9B,KAAK8B,KAAI;YACb,WAAU5B,IAAI4B,IAAI9B,QAAQ,aAAY;gBAClC,OAAON,OAAOS,MAAM,4CAA0C2B,IAAI9B;;;QAI1EN,OAAOK,qBAAqBG,IAAIG,MAAMH;;IAW1CR,OAAOqC,oBAAoB,SAASC;QAGhC,IAAIC,QAAQD,OAAOE,MAAM;QAEzB,IAAIC,UAAUF,MAAM;QACpBA,MAAMG,OAAO,GAAE;QAEf,IAAIC;QACJ,IAAG3C,OAAOE,KAAKuC,YAAYzC,OAAOE,KAAKuC,SAASG,eAAe,UAAS;YACpED,OAAO3C,OAAOE,KAAKuC,SAASI;eAE5B;YACAF,OAAOG,OAAOL;;QAIlB,WAAUE,SAAS,aAAY;YAC3BI,QAAQC,MAAMP,UAAU;YACxB;;QAIJ,IAAIQ,GAAEC;QACND,IAAIC,IAAIP;QAGR,IAAIQ,IAAIZ,MAAMa;QACd,IAAIC,OAAOd,MAAMY,IAAE;QAGnB,IAAIG;QACJ,IAAGD,gBAAgBE,OAAM;YACrBD,MAAMH,IAAI;eAGV;YACAG,MAAMH;;QAGV,IAAIK;QACJ,KAAI,IAAIC,IAAE,GAAGA,IAAIH,KAAKG,KAAI;YACtB,IAAIC,MAAMnB,MAAMkB;YAEhB,IAAGA,MAAMH,MAAM,KAAKH,MAAM,GAAE;gBACzBK,SAASP;;YAGZ,WAAUA,EAAES,SAAS,aAAY;gBAC7BX,QAAQC,MAAM,eAAaU,MAAI,0BAA0BT;gBACzD;gBACA;;YAEJA,IAAIA,EAAES;YACNR,IAAID;;QAGR;YACIU,aAAcV;YACbI,MAAOA;YACPG,QAASA;;;IAYlBxD,OAAO4D,eAAe,SAASC;QAC3B,IAAIC;QACJ,KAAI,IAAIC,KAAKF,QAAO;YAChB,KAAI,IAAIJ,KAAKI,OAAOE,IAAG;gBACnB,IAAGF,OAAOE,GAAGN,cAAcF,OAAM;oBAC7BO,EAAEL,KAAKI,OAAOE,GAAGN,GAAGjB,MAAM;uBAEzB,WAAUqB,OAAOE,GAAGN,OAAO,UAAS;oBACrCK,EAAEL,KAAKO,KAAKC,MAAMD,KAAKE,UAAUL,OAAOE,GAAGN;uBAE3C;oBACAK,EAAEL,KAAKI,OAAOE,GAAGN;;;;QAI7B,OAAOK;;IAWX9D,OAAOS,QAAQ,SAAS0D,KAAIC;QACxB,IAAGD,eAAeZ,OAAM;YACpB,KAAI,IAAIjD,KAAK6D,KAAI;gBACbpB,QAAQC,MAAM,WAAS1C,IAAE,OAAK6D,IAAI7D;;eAGtC;YACAyC,QAAQC,MAAM,YAAUmB;;QAE5B,IAAGlE,QAAQM,OAAO8D,cAAc,KAAKD,kBAAiB;YAClD;;QAEJ,IAAGnE,QAAQM,OAAO+D,SAAS,WAAU;YACjC,OAAO;eAEP;YACAC,QAAQC;;;IAehBvE,QAAQM;QAEJkE,UAAW;QACVC,UAAW;QACXL,YAAa;QACbC,MAAQ;YACL,WAAUC,YAAY,YAAYA,UAAU,OAAO,oBAAmB;gBAElE,OAAO;mBAEP;gBAEA,OAAO;;;;IClVnBvE,OAAOwB,WAAW,SAASmD;QAEvB,KAAIA,kBAAkBA,QAAQhE,OAAO,UAAS;YAC1C,OAAOX,OAAOS,MAAM;;QAGxB,KAAIT,OAAOE,KAAKyE,QAAQhE,KAAI;YAExB,IAAIiE,KAAK3E,QAAQuB,SAASqD,QAAQF;YAGlCC,KAAK3E,QAAQuB,SAASsD,SAASF;eAE/B;YACAA,KAAK5E,OAAOE,KAAKyE,QAAQhE;;QAG7B,OAAOiE;;IAKX3E,QAAQuB;QAEJqD,SAAU,SAASF;YAEf,IAAIC,KAAK5E,OAAO4D,eACZ3D,QAAQuB,SAASuD,KAChBJ;YAIL,OAAOC;;QAIVG;YAEG9C,OAAQ;YAGPnB,SAAU;YACVH,IAAK;YACLqE,YAAa;YACb5D,iBAAkB;YAUlB6D,QAAS;YACTC,aAAc;YACdrC;YAEAsC;YACAC;YACAC,SAAU;YACVC;YAGAC;YACAC;YACAC,cAAe;YACfC,SAAU;YAYVC,QAAS;YAGTzF,MAAO;YAEPuB,SAAU,SAASoB;gBAEhB,IAAGb,KAAKlB,YAAY,GAAE;oBAClBd,OAAOS,MAAMuB,KAAKrB,KAAK;;gBAI3BqB,KAAKiD,UAAU;gBAGfjD,KAAKa,QAASA;gBAId,KAAIb,KAAK4D,gBAAe;oBAEpB5D,KAAK4D,iBAAiB;oBAGtB,WAAU5D,KAAKX,aAAa,YAAW;wBACnC,OAAOpB,QAAQuB,SAASqE,oBAAoB7E,KAAKgB,MAAKA,KAAKX,UAASwB;;;gBAM5E,IAAIiD,GAAEC,IAAG5C,IAAEnB,KAAKoD,OAAOhC;gBACvB,KAAI,IAAI9C,IAAI,GAAGA,IAAE6C,GAAG7C,KAAI;oBAKpByF,KAAK/D,KAAKoD,OAAO1C,OAAO,GAAE;oBAG1BoD,IAAI7F,QAAQuB,SAASqE,oBAAoB7E,KAAKgB,MAAK+D,GAAG,IAAGD,KAAK9D,KAAKa;oBAInEb,KAAKwD,kBAAkBQ,KAAKD,GAAG;oBAK/B,WAAUD,MAAM,eAAeA,EAAE/D,MAAK;wBAGlCC,KAAKiD,SAAS;wBAGdjD,KAAKH,MAAKiE;wBAGV;2BAGC,WAAUA,MAAM,aAAY;wBAC7B9D,KAAKa,QAAQiD;;;gBAKrB,IAAG9D,KAAKiE,KAAI;oBAER,IAAGjE,KAAKiE,eAAe1C,OAAM;wBAEzB,IAAI5B,MAAM3B,OAAOqC,kBAAkBL,KAAKiE;wBACxCtE,IAAI6B,OAAO7B,IAAI0B,QAAQrB,KAAKa;2BAG3B,WAAWb,KAAKiE,QAAQ,YAAW;wBACpCjE,KAAKiE,IAAIjE,KAAKa;;;gBAKtB,KAAK,IAAIvC,KAAKN,OAAOK,sBAAqB;oBAGtC,WAAUL,OAAOK,qBAAqBC,GAAG4F,WAAW,cACzClG,OAAOK,qBAAqBC,GAAG4F,OAAOlF,KAAKgB,OAAM;wBACxD;;oBAGJ,IAAGhC,OAAOO,SAAS8D,YAAW;wBAC1BtB,QAAQoD,IAAI,4CAA0C7F,IAAE,UAAU0B,KAAKrB;;oBAG3EX,OAAOK,qBAAqBC,GAAGyF,GAAG/E,KAAKgB;;gBAI3C,IAAGA,KAAKkD,aAAY;oBAChBkB,aAAapE,KAAKkD;;gBAItBjF,QAAQuB,SAAS6E,WAAWrF,KAAKgB,MAAK;gBAEtCA,KAAKsE;gBAEL,OAAOtE;;YAGVuE,QAAS,SAASC;gBAEf,MAAKA,eAAejD,QAAO;oBACvBiD,QAAOA;;gBAGXA,IAAIC,QAAQ,cAAYzE,KAAKC,QAAM,QAAMD,KAAKrB,KAAG;gBAEjDX,OAAOS,MAAM+F;gBAGb,IAAGxE,KAAKkD,aAAY;oBAChBkB,aAAapE,KAAKkD;;gBAItBlD,KAAK0E,eAAeF;gBAGpBvG,QAAQuB,SAAS6E,WAAWrF,KAAKgB,MAAK;gBAGtC,KAAI,IAAI1B,KAAK0B,KAAKsD,UAAS;oBACvBtD,KAAKa,MAAMmD,KAAKhE,KAAKsD,SAAShF,GAAGqG,MAAM3E,MAAK4E;;gBAGhD,OAAO5E;;YAGVD,MAAO,SAASgE,IAAGc;gBAEhB,QAAO;kBAGH,KAAK7E,KAAKiD,WAAW;oBACjB;;kBAEJ,KAAKjD,KAAKgD,eAAe;oBACrBhF,OAAOS,MAAMuB,KAAKrB,KAAG;oBACrB;;kBAEJ,KAAKqB,KAAKlB,YAAY,KAAKkB,KAAKiD,WAAW,MAAMjD,KAAKgD;oBAClD,IAAI8B,IAAI7G,QAAQuB,SAASqE,oBAAoB7E,KAAKgB,MAAK+D,IAAG/D,KAAKa;oBAC/D,WAAUiE,MAAM,aAAY;wBACxB9E,KAAKa,QAAQiE;;oBAEjB;;kBAEJ;oBAGI9E,KAAKoD,OAAOY,KAAKD;oBAGjB,WAAUc,aAAa,YAAW;wBAC9B7E,KAAKsD,SAASU,KAAKa;;oBAEvB;;gBAGR,OAAO7E;;YAGVsE,MAAO,SAASP;gBAEb,IAAG/D,KAAKqD,YAAY,MAAK;oBACrB,IAAGU,IAAG;wBACF/D,KAAKqD,UAAUU;;uBAGlB,IAAGA,IAAG;oBACP/F,OAAOS,MAAM;oBACb;;gBAGJ,IAAGuB,KAAKlB,YAAY,KAAKkB,KAAKiD,WAAW,KAAKjD,KAAKqD,SAAQ;oBACvDrD,KAAKgD,aAAa;oBAClB/E,QAAQuB,SAASqE,oBAAoB7E,KAAKgB,MAAKA,KAAKqD,SAAQrD,KAAKa;;;;QAkB5EgD,qBAAsB,SAASE,IAAGnE;YAE/B,OAAOmE,GAAGnE,KAAII;;QAUjBqE,YAAa,SAASU;YAEnB/E,KAAKiD,SAAS8B;YAGd,IAAGA,QAAQ,KAAKA,QAAQ,GAAE;gBACtB/E,KAAKlB,UAAU;;YAGnBb,QAAQuB,SAASwF,mBAAmBhG,KAAKgB,MAAKA;;QAIjDiF,YAAa;YACV,OAAOjF,KAAKiD;;QAIfH,UAAW,SAAStE;YAGjB,KAAIA,IAAIG,IAAG;gBACPH,IAAIG,KAAKV,QAAQuB,SAAS0F,SAAS1G,IAAIyB;gBACvCzB,IAAI2G,YAAY;;YAIpB,IAAGnH,OAAOE,KAAKM,IAAIG,QAAQX,OAAOE,KAAKM,IAAIG,IAAI8E,cAAa;gBACxDzF,OAAOS,MAAM,wBAAsBD,IAAIG,KAAG;gBAC1C,OAAOX,OAAOE,KAAKM,IAAIG;mBAEvB;gBAEAX,OAAOE,KAAKM,IAAIG,MAAMH;;YAI1BP,QAAQuB,SAAS4F,aAAapG,KAAKR;YAEnC,OAAOA;;QAUV4G,cAAe,SAAS1B;YAErB1D,KAAK0D,iBAAkBA,YAAY,cAAe1D,KAAK0D,UAAUA;YAGjE,KAAI1D,KAAKqF,QAAQrF,KAAKqF,SAAS,SAAQ;gBAGnC,IAAGrF,KAAKkD,aAAY;oBAChBkB,aAAapE,KAAKkD;;gBAGtB,WAAUlD,KAAK0D,YAAY,aAAY;oBACnC1F,OAAOS,MAAMuB,KAAKrB,KAAG;uBAEpB,IAAIqB,KAAK0D,aAAa,GAAE;oBAEzB,OAAO;;gBAEX,IAAI4B,QAAQtF;gBAEZA,KAAKkD,cAAcqC,WAAW;oBAC1BtH,QAAQuB,SAASgG,gBAAgBxG,KAAKsG;mBACvCtF,KAAK0D;mBAER;YAGJ,OAAO;;QAUV8B,iBAAkB;YAEf,IAAGxF,KAAKiD,WAAW,GAAE;gBAGjB,IAAIwC;gBACJ,IAAIH,QAAQtF;gBAEZ,IAAI+D,KAAK,SAASvF;oBACd,IAAGA,IAAIyE,WAAW,GAAE;wBAChB,OAAOzE,IAAIG;2BAEX;wBACA,OAAO;;;gBAQf,IAAImG,IAAI7G,QAAQuB,SAASkG,uBAAuB1F,MAAK,YAAW+D;gBAChE0B,KAAKzB,KAAKsB,MAAM3G,KAAK,sCAAsCqB,KAAK0D,UAAU;gBAC1E+B,KAAKzB,KAAK;gBACVyB,KAAKzB,KAAKc;gBACV,OAAO7G,QAAQuB,SAASuD,IAAIwB,OAAOvF,KAAKgB,MAAKyF;;;QAMpDzE,OAAQ,SAAS2E;YAGd,IAAG3F,KAAKiD,WAAW,GAAE;gBACjB0C;mBAEA;gBACA3F,KAAKmD,QAAQa,KAAK2B;;YAGtB,OAAO3F;;QAIVkF,UAAW,SAASjF;YACjB,OAAO,eAAeA,QAAQ,MAAOjC,OAAOM;;QAc/C0G,oBAAqB,SAAS1E;YAG3B,KAAI,IAAIhC,KAAKgC,OAAOiD,YAAW;gBAC3B,IAAGjD,OAAOiD,WAAWjF,GAAGQ,YAAY,GAAE;oBAClCd,OAAOS,MAAM6B,OAAO3B,KAAK,8BAA4B,MAAI2B,OAAOiD,WAAWjF,GAAGK,KAAG;;;YAMzF,KAAK,IAAIL,KAAKgC,OAAOiD,YAAW;gBAC5B,IAAGjD,OAAOiD,WAAWjF,GAAGQ,YAAY,GAAE;oBAClCb,QAAQiB,MAAM0G,eAAetF,OAAOiD,WAAWjF,IAAGgC,OAAO3B;;;;QAgBpE+G,wBAAyB,SAASlH,KAAIqH,UAAS9B,IAAG+B;YAE/C,WAAUA,eAAe,aAAY;gBACjCA,eAActH,IAAIG;;YAGtB,IAAIoH;YAEJ,KAAI,IAAIzH,KAAKE,IAAIqH,WAAU;gBAGvBE,KAAKhC,GAAGvF,IAAIqH,UAAUvH;gBAEtB,IAAGyH,OAAO,OAAM;oBAGZ,IAAGD,WAAWE,QAAQD,SAAS,GAAE;wBAC7B,OAAO/H,OAAOS,QACV,6DACKoH,WAAS,yBACArH,IAAIG,OAAO,cAAe,MAAIH,IAAIG,KAAG,MAAM,MACpD,wBAAsBoH,IAC1B;4BACGD,WAAW9B,KAAK+B;4BAChB,OAAOD,WAAWG,KAAK;;;oBAKnCH,WAAW9B,KAAK+B;oBAEhB,IAAGvH,IAAIqH,UAAUvH,GAAGuH,WAAU;wBAC1B,OAAO5H,QAAQuB,SAASkG,uBAAuBlH,IAAIqH,UAAUvH,IAAGuH,UAAS9B,IAAG+B;;oBAGhF;;;YAKR,OAAOA;;QAUVI,oBAAqB,SAAS1H;YAG3B,KAAIA,IAAIG,IAAG;gBACP,IAAGH,IAAI6G,SAAS,SAAQ;oBACpB7G,IAAIG,KAAK,WAAWH,IAAIkF,UAAU,MAAI1F,OAAOM;uBAE5C,WAAUE,IAAI2H,QAAQ,UAAS;oBAChC3H,IAAIG,KAAKH,IAAI2H,IAAIC,MAAM,KAAKC;oBAE5B,IAAG7H,IAAIG,GAAG2H,OAAO,YAAW,GAAE;wBAC1B9H,IAAIG,KAAKH,IAAIG,GAAGyH,MAAM;wBACtB5H,IAAIG,GAAG0H;wBACP7H,IAAIG,KAAKH,IAAIG,GAAGsH,KAAK;;uBAGzB;oBACA,OAAOjI,OAAOS,QAAO,sBAAoBD,IAAI6G,OAAK,oCAAmC7G;;;YAI7F,IAAGA,IAAI6G,SAAS,SAAQ;gBAEpB,WAAUrH,OAAOE,KAAKM,IAAIG,QAAQ,aAAY;oBAC1C,OAAOX,OAAOE,KAAKM,IAAIG;;;YAK/B,IAAI4H;YACJ,QAAO;cAGH,KAAK/H,IAAI6G,SAAS;gBACdkB,OAAOtI,QAAQuB,SAASgH,YAAYhI;gBACpC;;cAGJ,KAAKA,IAAI6G,SAAS;cAClB,KAAK7G,IAAI6G,SAAS,aAAa7G,IAAIuB;gBAE/B,QAAO;kBAGH,YAAYvB,IAAIG,OAAO;oBACnBoC,QAAQ0F,KAAK,cAAYjI,IAAIG,KAAI;oBACjC4H,OAAOvI,OAAOwB;wBACVb,IAAKH,IAAIG;;oBAEb;;kBAGJ,YAAYH,IAAIkI,YAAY;oBACxB,IAAGlI,IAAI8G,OAAM;wBACTiB,OAAO/H,IAAIkI,QAAQ1H,KAAKR,IAAI8G;2BAE5B;wBACAiB,OAAO/H,IAAIkI;;oBAEf;;kBAGJ,KAAKlI,IAAQ;oBACT+H,OAAO/H;oBACP;;kBAEJ;gBAKJ,WAAU+H,SAAS,aAAaA,KAAKxG,MAAK;oBACtC,OAAO/B,OAAOS,MAAM,6DAA4DD;;gBAEpF;;cAEJ,KAAKA,IAAI6G,SAAS;gBACdkB,OAAOtI,QAAQuB,SAASmH,YAAYnI;gBACpC;;cAGJ;gBACIA,IAAI6G,OAAO7G,IAAI6G,QAAQ;gBACvBkB,OAAOtI,QAAQuB,SAASoH,UAAUpI;;YAI1CR,OAAOE,KAAKM,IAAIG,MAAM4H;YAEtB,OAAOA;;QAaVC,aAAc,SAAShI;YAEpB,IAAIK,MAAMb,OAAOwB;gBACbb,IAAKH,IAAIG;;YAIb,WAAU+D,aAAa,sBAAsB5B,WAAW,aAAY;gBAEhE,WAAU+F,MAAM,YAAW;oBACvB,IAAI1E,MAAM;oBACVtD,IAAI0F,OAAOpC;uBAEX;oBAEA,QAAO;sBACH,KAAK3D,IAAIG,OAAO,WAAWH,IAAIG,OAAO;wBAClCkI,EAAEnE,UAAUoE,MAAM;4BACdjI,IAAIY,QAAQ;;wBAEhB;;sBACJ,KAAKjB,IAAIG,OAAO;wBACZkI,EAAE/F,QAAQiG,KAAK;4BACXlI,IAAIY,QAAQ;;wBAEhB;;sBACJ;wBACIoH,EAAEnE,UAAUsE,GAAGxI,IAAIG,IAAG,QAAO;4BACzBE,IAAIY,QAAQ;;;;;YAMhC,OAAOZ;;QAIV8H,aAAc,SAASnI;YAEpB,IAAI+H,OAAOvI,OAAOwB,SAAShB;aAE1B,SAAS+H;gBAEN,IAAIU,SAAS,IAAIC,OAAOC;gBACxB5B,WAAW;oBACP,IAAI6B,OAAO,IAAIF,OAAOC;oBACtBZ,KAAK9G;wBACD4H,OAAQJ;wBACP3F,KAAM8F;wBACNE,SAAUF,OAAOH;wBACjBvD,SAAUlF,IAAIkF;;mBAErBlF,IAAIkF;eAER6C;YAEF,OAAOA;;QAUVK,WAAY,SAASW;YAGlB,IAAIC,aAAY,MAAK;YACrB,KAAI,IAAIlJ,KAAKkJ,UAAS;gBAClB,KAAID,IAAIC,SAASlJ,KAAI;oBACjB,OAAON,OAAOS,QACV,kDAAkD+I,SAASlJ,IAC1D,sFACAiJ;;;YAQb,IAAGvJ,OAAOE,KAAKqJ,IAAI5I,KAAI;gBACnB,OAAOX,OAAOE,KAAKqJ,IAAI5I;;YAK3B,IAAIa;YACJA,WAAWxB,OAAOwB,SAAS+H;YAC3B/H,WAAWvB,QAAQuB,SAASiI,WAAWjI,UAAS+H;YAChD,OAAO/H;;QAiBViI,YAAa,SAASjI,UAAS+H;YAG5B,IAAGA,IAAIpB,IAAI,OAAO,KAAI;gBAElB,IAAI1D,WAAWiF,KAAKnJ,SAASkE;gBAE7B,WAAUA,aAAa,UAAS;oBAC5BzE,OAAOS,QACC,gDAGA;uBAGR;oBACA8I,IAAIpB,MAAMoB,IAAIpB,IAAIwB,QAAQ,MAAKlF;;;YAMvC,WAAUF,YAAY,YAAYA,UAAU,OAAO,oBAAmB;gBAElEvC,KAAK4H,OAAO5H,KAAK4H,QAAQlF,SAASmF,qBAAqB,QAAQ,MAAMnF,SAASoF;gBAE9E,QAAO;kBAEH,KAAKP,IAAIlC,SAAO;oBAEZ,IAAI0C,OAAOrF,SAASsF,cAAc;oBAClCD,KAAK1C,OAAO;oBACZ0C,KAAKE,aAAa,OAAMV,IAAIpB;oBAC5B4B,KAAKE,aAAa,MAAKV,IAAI5I;qBAE1B,SAASoJ,MAAKR,KAAI/H;wBAEfuI,KAAKG,SAASH,KAAKI,qBAAqB;4BAGpC,KAAI3I,SAASJ,iBAAgB;gCACzBI,SAASC,eAAgBsI,KAAKlH,UAAU,cAAekH,KAAKlH,QAAQkH;;;wBAG5EA,KAAKK,UAAU;4BACX5I,SAAS+E,OAAO,0BAA0BgD,IAAIpB;;uBAEpD4B,MAAKR,KAAI/H;oBAGXQ,KAAK4H,KAAKS,YAAYN;oBACtB;;kBAEJ,KAAKR,IAAIlC,SAAO,SAASkC,IAAIlC,SAAO;oBAEhC,IAAI0C,OAAOrF,SAASsF,cAAc;oBAClCD,KAAKE,aAAa,QAAOV,IAAIpB;oBAC7B4B,KAAKE,aAAa,QAAO;oBACzBF,KAAKE,aAAa,OAAM;oBAExB,IAAGF,KAAKG,QAAO;yBACV,SAASH,MAAKR,KAAI/H;4BACfuI,KAAKG,SAASH,KAAKI,qBAAqB;gCACrC3I,SAASC,QAAQsI;;4BAGrBA,KAAKK,UAAU;gCACX5I,SAAS8I,QAAQ,0BAA0Bf,IAAIpB;;2BAGpD4B,MAAKR,KAAI/H;wBAEXQ,KAAK4H,KAAKS,YAAYN;wBACtB;2BAEA;wBAEA/H,KAAK4H,KAAKS,YAAYN;;;kBAG9B,KAAKR,IAAIlC,SAAO;kBAChB;oBAEI,IAAIP;oBACJ,IAAI1E,MAAM,IAAImI;oBACdnI,IAAIoI,KAAK,OAAOjB,IAAIpB,KAAK;oBAEzB,WAAUoB,IAAIkB,kBAAkB,aAAY;wBACxCrI,IAAIsI,iBAAiB,iBAAiBnB,IAAIkB;;oBAE9C,WAAUlB,IAAIoB,kBAAkB,aAAY;wBACxCvI,IAAIsI,iBAAiB,iBAAiBnB,IAAIoB;;qBAG7C,SAASpB,KAAI/H;wBACVY,IAAI+H,qBAAqB;4BACrB,IAAI/H,IAAIwI,eAAe,GAAG;gCACtB,IAAGxI,IAAIyI,WAAW,KAAI;oCAClB/D,IAAI1E,IAAI0I;oCACR,IAAGvB,IAAIlC,SAAS,QAAO;wCACnB;4CACIP,IAAI9C,KAAKC,MAAM6C;0CAEnB,OAAMiE;4CACF/K,OAAOS,QAAO,yBAAwB8I,IAAIpB,KAAIrB;;;oCAKtDtF,SAASC,QAAQsI,QAAQjD;uCAEzB;oCACAtF,SAAS+E,OAAO,mBAAiBgD,IAAIpB;;;;uBAInDoB,KAAI/H;oBAENY,IAAI4I,KAAK;;mBAIjB;gBAEA,SAASC,eAAezJ,UAASZ,MAAK2I;oBAElC,QAAO;sBAEH,KAAKA,IAAIlC,SAAS;wBACdzG,OAAOoD,KAAKC,MAAMrD;wBAClBY,SAASC,QAAQb;wBACjB;;sBAEJ;wBACIY,SAASC,QAAQb;;;gBAK7B,IAAG2I,IAAI5D,QAAO;oBACV,IAAIuF,UAAUC,QAAQ;oBACtBD,QAAQE,IAAI7B,IAAIpB,KAAK,SAAUnF,OAAOqI,UAAUC;wBAC5C,KAAKtI,SAASqI,SAASE,cAAc,KAAK;4BACtCN,eAAezJ,UAAS8J,MAAK/B;;;uBAKrC;oBAGA,IAAGA,IAAIlC,SAAS,UAAS;wBACrB,IAAIzG,OAAOuK,QAAQ5B,IAAIpB;wBAEvB,KAAI3G,SAASJ,iBAAgB;4BACzBI,SAASC,QAAQb;;2BAIpB,IAAG2I,IAAIlC,SAAS,OAAM;wBAEvB,IAAGpH,QAAQM,OAAOmE,aAAa,MAAK;4BAChC,IAAIqF,OAAO9J,QAAQM,OAAOmE,SAAS,QAAQ8G,OAAO,kCAAgCjC,IAAIpB,MAAI;4BAC1F3G,SAASC,QAAQsI;+BAEjB;4BACA,OAAO/J,OAAOS,QAAO8I,IAAIpB,KAAI;;2BAGjC;wBAEA,IAAIsD,KAAKN,QAAQ;yBAEhB,SAAS3J,UAAS+H;4BAEfkC,GAAGC,SAASnC,IAAIpB,KAAK,QAAQ,SAAU3B,KAAK5F;gCAExC,IAAI4F,KAAI;oCACJxG,OAAOS,QAAO,UAAU8I,IAAIpB,MAAM,iCAAiCoB,IAAIpB,MAAK,KAAI,UAAQ5D,QAAQoH;oCAChGpH,QAAQC;;gCAGZyG,eAAezJ,UAASZ,MAAK2I;;2BAGnC/H,UAAS+H;;;;YAQvB,OAAO/H;;;IC95BfxB,OAAOkB,QAAQ,SAAS0K,MAAKjH;QAEzB,IAAIC;QACJ,MAAKgH,gBAAgBrI,QAAO;YACxB,OAAOvD,OAAOS,MAAM;;QAGxB,KAAIkE,YAAYA,QAAQhE,IAAG;YACvB,OAAOX,OAAOS,MAAM;;QAIxB,KAAIT,OAAOE,KAAKyE,QAAQhE,KAAI;YAGxB,IAAIiE,KAAK3E,QAAQiB,MAAM2D,QAAQF;YAG/BC,KAAK3E,QAAQiB,MAAM4D,SAASF,IAAGD,SAAQiH;eAItC;YAEDhH,KAAK5E,OAAOE,KAAKyE,QAAQhE;YAEzB,IAAGiE,GAAG3C,UAAU,SAAQ;gBAGpB0C,QAAQc,eAAe;gBAEvBb,KAAK3E,QAAQiB,MAAM2K,QAAQjH,IAAGD,SAAQiH;mBAEtC;gBAGA,KAAI,IAAItL,KAAKqE,SAAQ;oBACjBC,GAAGtE,KAAKqE,QAAQrE;;gBAIpB,IAAGsL,KAAKxI,SAAS,GAAE;oBACfnD,QAAQiB,MAAM6D,IAAIlD,IAAIb,KAAK4D,IAAGgH;;;YAMtChH,GAAGkH,yBAA0BnH,QAAQmH,oBAAoB,cACzDnH,QAAQmH,kBAAkB;;QAG9B,OAAOlH;;IAIX3E,QAAQiB;QAGJ2D,SAAU,SAASF;YAGf,IAAIC,KAAK5E,OAAO4D,eACZ3D,QAAQuB,SAASuD,KAChB9E,QAAQiB,MAAM6D,KACdJ;YAIL,OAAOC;;QASVG;YAEG9C,OAAQ;YAIP2D,gBAAiB;YAMjBkG,iBAAkB;YAIlBC;YAIAC;YAqBAnK,KAAM,SAASD;gBAEZ;oBACI,IAAGA,IAAIwB,WAAW,GAAG,OAAOpB,KAAK+J;kBAErC,OAAMvF;oBACFxG,OAAOS,MAAM+F;;gBAIjB,IAAGxE,KAAKiD,WAAW,GAAE;oBACjB,OAAOjF,OAAOS,MAAM,kCAAgCuB,KAAKrB,KACxD;;gBAGL,KAAI,IAAIoD,KAAKnC,KAAI;oBAEb,QAAO;sBAGH,YAAY5B,OAAOE,KAAK0B,IAAImC,GAAG,WAAW;wBACtCnC,IAAImC,KAAK/D,OAAOE,KAAK0B,IAAImC,GAAG;wBAC5B;;sBAGJ,YAAYnC,IAAImC,OAAO,mBAAmBnC,IAAImC,GAAGhC,SAAS;wBACtDH,IAAImC,KAAK9D,QAAQuB,SAAS0G,mBAAmBtG,IAAImC;wBACjD;;sBAGJ,YAAYnC,IAAImC,GAAGhC,SAAS;wBACxB;;sBAEJ;wBACIgB,QAAQC,MAAM;wBACdD,QAAQC,MAAMpB,IAAImC;wBAClB;wBACA;;oBAIR,KAAI,IAAIN,KAAKzB,KAAKuD,YAAW;wBACzB,IAAG9B,MAAM7B,IAAImC,GAAGpD,IAAG;4BACf,OAAOX,OAAOS,MAAM,uCAAqCmB,IAAImC,GAAGpD,KAAG,eAAa,OAAKqB,KAAKrB,KAAG,8BAA4BiB,IAAImC,GAAGpD,KAAG,sDAAoDqB,KAAKrB,KAAG;;;oBAKvMqB,KAAK+J,SAASnK,IAAImC,GAAGpD,MAAMiB,IAAImC;oBAC/BnC,IAAImC,GAAGwB,WAAWvD,KAAKrB,MAAMqB;oBAC7BA,KAAKgK,aAAahG,KAAKpE,IAAImC;;gBAI/B,OAAO/B,KAAK+J;;YAUf7J,QAAS,SAASN;gBAGf,IAAGI,KAAKiD,WAAW,GAAE;oBACjBlC,QAAQC,MAAM,uCAAqChB,KAAKrB,KAAG;oBAC3D,OAAO;;gBAGX,KAAI,IAAIoD,KAAKnC,KAAI;oBACb,IAAGI,KAAK+J,SAASnK,IAAImC,GAAGpD,KAAI;+BACjBqB,KAAK+J,SAASnK,IAAImC,GAAGpD;+BACrBiB,IAAImC,GAAGwB,WAAWvD,KAAKrB;;;;YAazCsL,OAAQ,SAAStH;gBAEd,IAAG3C,KAAKlB,YAAY,KAAKkB,KAAKiD,WAAW,GAAE;oBACvCjF,OAAOS,MAAM;;gBAGjBkE,UAAUA;gBAEV3C,KAAKlB,UAAU;gBACfkB,KAAKiD,SAAS;gBACdjD,KAAK4D,iBAAiB;gBACtB5D,KAAKgD,aAAa;gBAGlB,IAAGhD,KAAKkD,aAAY;oBAChBkB,aAAapE,KAAKkD;;gBAItBlD,KAAKuD;gBACLvD,KAAKgK;gBAGL/L,QAAQuB,SAAS4F,aAAapG,KAAKgB,MAAK2C,QAAQe;gBAKhD,OAAO1D;;YAkBVkK,YAAa;gBACVjM,QAAQiB,MAAM0G,eAAe5F,MAAKA,KAAKrB;gBACvC,OAAOqB,KAAKiD;;;QAkBnBH,UAAW,SAAShB,GAAEa,SAAQiH;YAG3B9H,IAAI7D,QAAQuB,SAASsD,SAAShB;YAG9B7D,QAAQiB,MAAM6D,IAAIlD,IAAIb,KAAK8C,GAAE8H;YAG7B3L,QAAQiB,MAAM0G,eAAe9D,GAAEA,EAAEnD;YAGjC,IAAGmD,EAAEpC,QAAO;gBACR,KAAI,IAAIqC,KAAKD,EAAEpC,QAAO;oBAClB1B,OAAO0B,OAAOoC,EAAEpC,OAAOqC,MAAID,KAAG;;;YAItC,OAAOA;;QAcV8D,gBAAiB,SAAStF,QAAO6J;YAE9B,IAAG7J,OAAOwJ,oBAAoB,GAAG;YAIlC,IAAGK,YAAY7J,OAAO3B,OAAO2B,OAAOyJ,SAASI,UAAS;gBAClDpJ,QAAQC,MAAMmJ,UAAU,mBAAmB7J,OAAO3B,KAAK;gBACvD;gBACA;mBAGA;gBACA,IAAIkK,SAAS;gBACb,KAAI,IAAIvK,KAAKgC,OAAOyJ,UAAS;oBAEzB,IAAGzJ,OAAOyJ,SAASzL,GAAG2E,WAAW,GAAG;wBAChC4F,SAASvI,OAAOyJ,SAASzL,GAAG2E;wBAC5B;;;;YAMZ,IAAG4F,WAAW,GAAE;gBAIX,IAAIuB;gBACJ,KAAI,IAAI9L,KAAKgC,OAAO0J,cAAa;oBAC7BI,OAAOpG,KAAK1D,OAAO0J,aAAa1L,GAAGuC;;gBAGvC5C,QAAQuB,SAASuD,IAAItD,QAAQT,KAAKsB,QAAO8J;;YAG9C,IAAGvB,WAAW,GAAE;gBACZ,IAAIrE,QACAlE,OAAO3B,KAAG,kBAAgB2B,OAAOyJ,SAASzL,GAAGK,KAAK,mBACjD2B,OAAOyJ,SAASzL,GAAGsG;gBAExB3G,QAAQuB,SAASuD,IAAIwB,OAAOI,MAAMrE,QAAOkE;;;QAa/CqF,SAAU,SAASrL,KAAImE,SAAQiH;YAE5B,IAAGpL,IAAIM,YAAY,KAAMN,IAAIyB,UAAU,aAAazB,IAAIyB,UAAU,YAAY;gBAC1E,OAAOjC,OAAOS,MAAM;;YAIxB,IAAImE,KAAK5E,OAAO4D,eACZ3D,QAAQiB,MAAM6D,KACbJ;YAGL,KAAI,IAAIrE,KAAKsE,IAAG;gBACbpE,IAAIF,KAAKsE,GAAGtE;;mBAGRsE;YAGPpE,MAAMP,QAAQiB,MAAM4D,SAAStE,KAAImE,SAAQiH;YAGzC,OAAOpL;;;IC7XfR,OAAOqM,OAAO,SAAS7L;QAEnB,IAAIgJ,aAAY,QAAO,SAAQ;QAC/B,KAAI,IAAIlJ,KAAKkJ,UAAS;YAClB,KAAIhJ,IAAIgJ,SAASlJ,KAAI;gBACjB,OAAON,OAAOS,MAAM,+BAA+B+I,SAASlJ;;;QAKpE,IAAIkB,WAAWxB,OAAOwB;YAClBb,IAAKH,IAAIG;;QAIb,IAAIU,WAAW;YACXG,SAASC,QAAQT,KAAKQ,UAASoF,UAAU;;QAI7CpG,IAAIuB,KAAKV;QAGT,IAAImF,MAAM,SAASA;YACfhF,SAAS+E,OAAOC;;QAIpBhG,IAAIwC,MAAMwD;QAGV,OAAOhF;;IC/BX,WAAU+C,YAAY,YAAYA,UAAU,OAAO,oBAAmB;QAElE+H,OAAOxM,UAAUE;WAEjB;QAEA0J,OAAO1J;;OLNuE;IAAW,OAAOgC","sourcesContent":[null,"var public = {};\nvar private = {};\n\n\n////////////////////////////////////////\n//  PUBLIC VARIABLES\n////////////////////////////////////////\n\n\n/**\n * A directory of all promises, deferreds, and queues.\n * @type object\n */\npublic.list = {};\n\n\n/**\n * Array of all exported modules\n * @type Array\n */\npublic.modules_exported = [];\n\n\n/**\n * Index number of last module loaded in public.modules_exported\n * @type Number\n */\npublic.modules_loaded = 0;\n\n\n/** \n * Callbacks that are run on every resolved item\n * \n */\npublic.registered_callbacks = {};\n\n\n/**\n * iterator for ids\n * @type integer\n */\npublic.i = 0;\n\n\n////////////////////////////////////////\n//  PUBLIC METHODS\n////////////////////////////////////////\n\n\n/**\n * Stores document context for nodejs.\n * \n * @type string\n */\npublic.config = function(obj){\n    \n    if(obj){\n        for(var i in obj){\n            if(typeof private.config[i] !== 'undefined'){\n                private.config[i] = obj[i];\n            }\n            else{\n                return public.debug(\"Property '\"+i+\"' is not configurable.\");\n            }\n        }\n    }\n    \n    \n    return private.config;\n}\n\n\n/**\n* Creates a new promise from a value and an id and automatically resolves it.\n* \n*     obj.__has_ui = (typeof obj.__has_ui !== 'undefined') ? false : obj.__has_ui;\n* \n* @param {string} id\n* @param {mixed} data\n* @returns {object} resolved promise\n*/\npublic.define = function(id,data){\n    \n    var def;\n\n    //MAKE SURE NOT TRYING TO RESOLVE EXISTING DEF\n    if(public.list[id] && public.list[id].settled === 1){\n        return public.debug(\"Can't define \" + id + \". Already resolved.\",true);\n    }\n\n    data.__dependencies = (typeof data.__dependencies === 'function') \n        ? data.__dependencies.call(data) \n        : data.__dependencies;\n    \n    //ORGY MODULE HANDLING\n    if(typeof data === 'object' && typeof data.__id === 'string'){\n        \n        def = public.queue(data.__dependencies || [],{\n            id : id\n            ,__ui : (typeof data.__ui !== 'undefined') ? data.__ui : 1\n            ,_is_orgy_module : 1\n            ,resolver : (typeof data.__resolver === 'function')\n            ? data.__resolver.bind(data) : null\n        });\n    }\n    else{\n\n        //CREATE/GET DEFERRED\n        def = public.deferred({\n           id : id\n        });\n\n        //SETTLE \n        def.resolve(data);\n       \n    }\n    \n    return def;\n};\n\n\n/**\n * Add/remove an upstream dependency to/from a queue. \n * \n * Can use a queue id, even for a queue that is yet to be created.\n * \n * @param {string} tgt | queue / queue id\n * @param {array}  arr | list/promise ids,dependencies\n * @param {boolean} add | add if true, remove if false\n * \n * @return {array} queue of list\n */\npublic.assign = function(tgt,arr,add){\n\n    add = (typeof add === \"boolean\") ? add : 1;\n\n    var id,q;\n    switch(true){\n        case(typeof tgt === 'object' && typeof tgt.then === 'function'):\n            id = tgt.id;\n            break;\n        case(typeof tgt === 'string'):\n            id = tgt;\n            break;\n        default:\n            return public.debug(\"Assign target must be a queue object or the id of a queue.\");\n    }\n\n    //IF TARGET ALREADY LISTED\n    if(this.list[id] && this.list[id].model === 'queue'){\n        q = this.list[id];\n        \n        //=> ADD TO QUEUE'S UPSTREAM\n        if(add){\n            q.add(arr);\n        }\n        //=> REMOVE FROM QUEUE'S UPSTREAM\n        else{\n            q.remove(arr);\n        }\n    }\n    //CREATE NEW QUEUE AND ADD DEPENDENCIES\n    else if(add){\n\n        q = public.queue(arr,{\n            id : id\n        });\n    }\n    //ERROR: CAN'T REMOVE FROM A QUEUE THAT DOES NOT EXIST\n    else{\n        public.debug(\"Cannot remove dependencies from a queue that does not exist.\");\n    }\n\n    return q;\n};\n\n\npublic.register_callback = function(obj){\n    \n    var req = ['id','fn'];\n    for(var i in req){\n        if(typeof obj[req[i]] === 'undefined'){\n            return public.debug(\"registered callbacks require property: \"+req[i]);\n        }\n    }\n    \n    public.registered_callbacks[obj.id] = obj;\n};\n\n    \n/**\n * Converts a specially formatted array into a function.\n * \n * \n * @param {type} target\n * @returns {object}\n */\npublic.array_to_function = function(target){\n\n    //CLONE TARGET\n    var clone = target.slice(0);\n\n    var root_id = clone[0];\n    clone.splice(0,1);\n\n    var root;\n    if(public.list[root_id] && public.list[root_id].hasOwnProperty(\"value\")){\n        root = public.list[root_id].value; \n    }\n    else{\n        root = window[root_id];\n    }\n\n\n    if(typeof root === 'undefined'){\n        console.error(root_id + \" not found on window or public.list\");\n        debugger;\n    }\n\n\n    var x,y;\n    x = y = root;\n\n    //REMOVE LAST ARRAY ELEMENT (ARGS)\n    var l = clone.length;\n    var args = clone[l-1];\n\n    //POINTER TO A FUNCTION WILL HAVE AN ARRAY AS LAST ELEMENT\n    var end;\n    if(args instanceof Array){\n        end = l - 1;\n    }\n    //POINTER TO AN ARRAY WILL NOT\n    else{\n        end = l;\n    }\n\n    var parent;\n    for(var b=0; b < end; b++){\n        var key = clone[b];\n\n        if(b === end - 1 || l === 1){\n           parent = x; \n        }\n\n        if(typeof x[key] === 'undefined'){\n            console.error(\"Property '\"+key+\"' not found on object:\", x);\n            debugger;\n            return;\n        }\n        x = x[key];\n        y = x;\n    }    \n\n    return {\n        constructor : x\n        ,args : args\n        ,parent : parent\n    };\n}\n\n\n/**\n * Makes a shallow copy of an array. \n * Makes a copy of an object so long as it is JSON\n * \n * @param {array} array of donor objects, overwritten from right to left\n * @returns {object}\n */\npublic.naive_cloner = function(donors){\n    var o = {};\n    for(var a in donors){\n        for(var b in donors[a]){\n            if(donors[a][b] instanceof Array){\n                o[b] = donors[a][b].slice(0);\n            }\n            else if(typeof donors[a][b] === 'object'){\n                o[b] = JSON.parse(JSON.stringify(donors[a][b]));\n            }\n            else{\n                o[b] = donors[a][b];\n            }\n        }\n    }\n    return o;\n}\n        \n\n/**\n * Debugging method.\n * \n * @param {string|array} msg\n * @param {boolean} force_debug_mode   Forces debugger when set to true. \n * @returns {Boolean}\n */\npublic.debug = function(msg,force_debug_mode){\n    if(msg instanceof Array){\n        for(var i in msg){\n            console.error(\"ERROR-\"+i+\": \"+msg[i]);\n        }\n    }\n    else{\n        console.error(\"ERROR: \"+msg);\n    }\n    if(private.config.debug_mode == 1 || force_debug_mode){\n        debugger;\n    }\n    if(private.config.mode === 'browser'){\n        return false;\n    }\n    else{\n        process.exit();\n    }\n}\n\n\n////////////////////////////////////////\n//  PRIVATE VARIABLES\n////////////////////////////////////////\n\n\n/**\n * Configuration values.\n * \n * @type object\n */\nprivate.config = {\n    \n    autopath : ''\n    ,document : null\n    ,debug_mode : 1\n    ,mode : (function(){\n        if(typeof process === 'object' && process + '' === '[object process]'){\n            // is node\n            return \"node\"\n        }\n        else{\n            // not node\n            return \"browser\"\n        }\n    }())\n};","public.deferred = function(options){\n    \n    if(!options || typeof options.id !== 'string'){\n        return public.debug(\"Must set id.\");\n    }\n    \n    if(!public.list[options.id]){\n        //CREATE NEW INSTANCE OF DEFERRED CLASS\n        var _o = private.deferred.factory(options);\n\n        //ACTIVATE DEFERRED\n        _o = private.deferred.activate(_o);\n    }\n    else{\n        _o = public.list[options.id];\n    }\n    \n    return _o;\n};\n\n\n\nprivate.deferred = {\n    \n    factory : function(options){\n        \n        var _o = public.naive_cloner([\n            private.deferred.tpl\n            ,options\n        ]);\n\n        //YOU NOW HAVE A DEFERRED OBJECT THAT IS INACTIVE ON THE OrgyLIST\n        return _o;\n    }\n    \n    \n    ,tpl : {\n        \n        model : \"deferred\"\n\n        //A COUNTER FOR AUT0-GENERATED PROMISE ID'S\n        ,settled : 0 \n        ,id : null\n        ,done_fired : 0\n        ,_is_orgy_module : 0\n        \n        /**\n         * STATE CODES:\n         * ------------------\n         * -1   => SETTLING [EXECUTING CALLBACKS]\n         *  0   => PENDING\n         *  1   => RESOLVED / FULFILLED\n         *  2   => REJECTED \n         */\n        ,_state : 0\n        ,_timeout_id : null\n        ,value : []\n\n        ,error_q : []  \n        ,then_q : []\n        ,done_fn : null\n        ,reject_q : []\n\n        //PROMISE HAS OBSERVERS BUT DOES NOT OBSERVE OTHERS\n        ,downstream : {}\n        ,execution_history : []\n        ,overwritable : 0   //WHEN TRUE, ALLOWS RE-INIT [FOR UPGRADES TO A QUEUE]          \n        ,timeout : 5000\n\n        /**\n         * REMOTE\n         * \n         * REMOTE == 1  =>  [DEFAULT] Make http request for file\n         * \n         * REMOTE == 0  =>  Read file directly from the filesystem\n         * \n         * ONLY APPLIES TO SCRIPTS RUN UNDER NODE AS BROWSER HAS NO \n         * FILESYSTEM ACCESS\n         */\n        ,remote : 1\n\n        //ADDS TO MASTER LIST. ALWAYS DO THIS UNLESS UPGRADING A PROMISE TO A QUEUE\n        ,list : 1   \n\n        ,resolve : function(value){\n\n            if(this.settled !== 0){\n                public.debug(this.id + \" can't resolve. Only unsettled promise objects resolvable.\");\n            }\n\n            //SET STATE TO SETTLEMENT IN PROGRESS\n            this._state = -1; \n\n            //SET VALUE\n            this.value  = value;\n\n            //RUN RESOLVER BEFORE PROCEEDING\n            //EVEN IF THERE IS NO RESOLVER, SET IT TO FIRED WHEN CALLED\n            if(!this.resolver_fired){\n\n                this.resolver_fired = 1;\n\n                //FIRE THE RESOLVER IF SET\n                if(typeof this.resolver === 'function'){\n                    return private.deferred.hook_before_success.call(this,this.resolver,value);\n                }\n\n            }\n\n            //Allows .then chain to be held up by new async events created as the chain executes.\n            var v,fn,l=this.then_q.length;\n            for(var i = 0; i<l; i++){     \n\n                //REMOVE fn FROM THEN QUEUE. \n                //WHEN A PROMISE OBJ IS RETURNED, AND EXECUTION STOPPED WE\n                //DONT WANT TO REPEAAT A CALL TO SAME fn\n                fn = this.then_q.splice(0,1);\n\n                //CALL fn WITH PRECEDING RESULT OR IF NONE EXISTS, THE RESOLVER VALUE \n                v = private.deferred.hook_before_success.call(this,fn[0],v || this.value);\n                //v = fn[0].call(this, v || this.value);\n                \n                //SAVE fn TO EXECUTION HISTORY\n                this.execution_history.push(fn[0]);\n\n                //IF fn RETURNED AN UNSETTLED PROMISE\n                //Orgy FOR IT TO RESOLVE BEFORE PROCEEDING\n                //AND ADD THE RESULT TO THE END OF VALUE ARRAY\n                if(typeof v !== 'undefined' && v.then){\n                    \n                    //SET THE STATE BACK TO OrgyING\n                    this._state = 0;\n                    \n                    //ADD IT TO QUEUE'S UPSTREAM\n                    this.add([v]);\n                    \n                    //END RESOLUTION ATTEMPT AND Orgy FOR v TO RESOLVE\n                    return;\n                }\n                //IF V RETURNED A VALUE MAKE IT THE NEW QUEUE VALUE\n                else if(typeof v !== 'undefined'){\n                    this.value = v;\n                }\n            }\n                        \n            //SET RETURN VALUE TO A GIVEN OBJECT PROPERTY\n            if(this.set){\n                //ARRAY IS TRANSORMED INTO A PATH TO POINT TO\n                if(this.set instanceof Array){\n                    //@todo make property of private to avoid external dependency\n                    var tgt = public.array_to_function(this.set);\n                    tgt.parent[tgt.args] = this.value;\n                }\n                //OTHErWISE ASSUMED TO BE AN OBJECT PROPERTY\n                else if (typeof this.set === 'function'){\n                    this.set(this.value);\n                }\n            }\n\n            //EXECUTE ANY GLOBALLY REGISTERED CALLBACKS\n            for (var i in public.registered_callbacks){\n\n                //SKIP IF FILTER RETURNS TRUE\n                if(typeof public.registered_callbacks[i].filter === 'function'\n                        && public.registered_callbacks[i].filter.call(this)){\n                    continue;\n                }\n                \n                if(public.config().debug_mode){\n                    console.log(\"Orgy.js executing registered callback '\"+i+\"' on \" + this.id);\n                }\n                \n                public.registered_callbacks[i].fn.call(this);\n            }\n           \n            //REMOVE AUTO TIMEOUT TIMER\n            if(this._timeout_id){\n                clearTimeout(this._timeout_id);\n            }\n\n            //SET STATE TO RESOLVED\n            private.deferred._set_state.call(this,1);\n\n            this.done();\n                \n            return this;\n        }\n\n        ,reject : function(err){\n            \n            if(!(err instanceof Array)){\n                err = [err]\n            }\n            \n            err.unshift(\"REJECTED \"+this.model+\": '\"+this.id+\"'\");\n\n            public.debug(err);\n\n            //REMOVE AUTO TIMEOUT TIMER\n            if(this._timeout_id){\n                clearTimeout(this._timeout_id);\n            }\n\n            //SAVE ERROR OBJECT TO MEMORY FOR USE IN CATCH CALLBACK\n            this.catch_params = err;\n\n            //SET STATE TO REJECTED\n            private.deferred._set_state.call(this,2);\n\n            //EXECUTE REJECTION QUEUE\n            for(var i in this.reject_q){\n                this.value.push(this.reject_q[i].apply(this,arguments));\n            }\n\n            return this;\n        }\n\n        ,then : function(fn,rejector){\n\n            switch(true){\n\n                //ERROR WAS PREVIOUSLY THROWN\n                case(this._state === 2):\n                    break;\n\n                case(this.done_fired === 1):\n                    public.debug(this.id+\" can't attach .then() after .done() has fired.\");\n                    break;\n\n                case(this.settled === 1 && this._state === 1 && !this.done_fired):\n                    var r = private.deferred.hook_before_success.call(this,fn,this.value);\n                    if(typeof r !== 'undefined'){\n                        this.value = r;\n                    }\n                    break;\n\n                default:\n\n                    //PUSH CALLBACK TO THEN QUEUE\n                    this.then_q.push(fn);\n\n                    //PUSH REJECT CALLBACK TO REJECTION QUEUE\n                    if(typeof rejector === 'function'){\n                        this.reject_q.push(rejector);\n                    }\n                    break;\n            }\n\n            return this;\n        }\n        \n        ,done : function(fn){\n            \n            if(this.done_fn === null){\n                if(fn){\n                    this.done_fn = fn\n                }\n            }\n            else if(fn){\n                public.debug(\"done() can only be called once.\");\n                return;\n            }\n            \n            if(this.settled === 1 && this._state === 1 && this.done_fn){\n                this.done_fired = 1;\n                private.deferred.hook_before_success.call(this,this.done_fn,this.value);\n            }\n        }\n\n    }\n\n    \n    ///////////////////////////////////////////////////\n    //  METHODS\n    ///////////////////////////////////////////////////\n    \n    \n    /**\n     * Methods to run before then(), done() \n     * \n     * @param {type} fn\n     * @returns {undefined}\n     */\n    ,hook_before_success : function(fn,arr){\n        \n        return fn(arr,this);\n\n    }\n    \n    \n    /**\n     * \n     * @param {type} int\n     * @returns {undefined}\n     */\n    ,_set_state : function(int){\n\n        this._state = int;\n\n        //IF RESOLVED OR REJECTED, SETTLE\n        if(int === 1 || int === 2){\n            this.settled = 1;\n        }\n\n        private.deferred._signal_downstream.call(this,this);\n    }\n    \n    \n    ,_get_state : function(){\n        return this._state;\n    }\n\n\n    ,activate : function(obj){\n\n        //SET ID\n        if(!obj.id){\n            obj.id = private.deferred._make_id(obj.model);\n            obj.autonamed = true;\n        }\n\n        //MAKE SURE NAMING CONFLICT DOES NOT EXIST\n        if(public.list[obj.id] && !public.list[obj.id].overwritable){\n            public.debug(\"Tried to overwrite \"+obj.id+\" without overwrite permissions.\");\n            return public.list[obj.id];\n        }\n        else{\n            //SAVE TO MASTER LIST\n            public.list[obj.id] = obj;\n        }\n\n        //AUTO TIMEOUT\n        private.deferred.auto_timeout.call(obj);\n\n        return obj;\n    }\n\n\n    /**\n     * Sets the automatic timeout on a promise object.\n     * \n     * @param {integer} optional. timeout\n     * @returns {Boolean}\n     */\n    ,auto_timeout : function(timeout){\n\n        this.timeout = (typeof timeout === 'undefined') ? this.timeout : timeout;\n\n        //AUTO REJECT ON timeout\n        if(!this.type || this.type !== 'timer'){\n\n            //DELETE PREVIOUS TIMEOUT IF EXISTS\n            if(this._timeout_id){\n                clearTimeout(this._timeout_id);\n            }\n\n            if(typeof this.timeout === 'undefined'){\n                public.debug(this.id+\" Auto timeout this.timeout cannot be undefined.\");\n            }\n            else if (this.timeout === -1){\n                //NO AUTO TIMEOUT SET\n                return false;\n            }\n            var scope = this;\n\n            this._timeout_id = setTimeout(function(){\n                private.deferred.auto_timeout_cb.call(scope);\n            }, this.timeout);\n        }\n        else{\n            //@todo WHEN A TIMER, ADD DURATION TO ALL UPSTREAM AND LATERAL?\n        }\n        return true;\n    }\n\n\n    /**\n     * Callback for autotimeout. Declaration here avoids memory leak.\n     * \n     * @param {type} exp\n     * @returns {undefined}\n     */\n    ,auto_timeout_cb : function(){\n        \n        if(this._state !== 1){\n\n            //GET THE UPSTREAM ERROR ID\n            var msgs = [];\n            var scope = this;\n\n            var fn = function(obj){\n                if(obj._state !== 1){\n                    return obj.id\n                }\n                else{\n                    return false;\n                }\n            };\n\n            /**\n             * Run over a given object property recursively, applying callback until \n             * callback returns a non-false value.\n             */\n            var r = private.deferred.search_obj_recursively(this,'upstream',fn);\n            msgs.push(scope.id + \": rejected by auto timeout after \" + this.timeout + \"ms\");\n            msgs.push(\"Cause:\");\n            msgs.push(r);\n            return private.deferred.tpl.reject.call(this,msgs);\n            \n        }\n    }\n\n\n    ,error : function(cb){\n\n        //IF ERROR ALREADY THROWN, EXECUTE CB IMMEDIATELY\n        if(this._state === 2){\n            cb();\n        }\n        else{\n            this.error_q.push(cb);\n        }\n\n        return this;\n    }\n\n\n    ,_make_id : function(model){\n        return \"anonymous-\" + model + \"-\" + (public.i++);\n    }\n\n\n    /**\n     * Signals all downstream promises that private promise object's state has changed.\n     * \n     * \n     * @todo Since the same queue may have been assigned twice directly or \n     * indirectly via shared dependencies, make sure not to double resolve\n     * - which throws an error.\n     *     \n     * @returns {void}\n     */\n    ,_signal_downstream : function(target){\n\n        //MAKE SURE ALL DOWNSTREAM IS UNSETTLED\n        for(var i in target.downstream){\n            if(target.downstream[i].settled === 1){\n                public.debug(target.id + \" tried to settle promise \"+\"'\"+target.downstream[i].id+\"' that has already been settled.\");\n            }\n        }\n\n        //NOW THAT WE KNOW ALL DOWNSTREAM IS UNSETTLED, WE CAN IGNORE ANY\n        //SETTLED THAT RESULT AS A SIDE EFFECT TO ANOTHER SETTLEMENT\n        for (var i in target.downstream){\n            if(target.downstream[i].settled !== 1){\n                private.queue.receive_signal(target.downstream[i],target.id);\n            }\n        }\n    }\n    \n    \n    /**\n    * Run over a given object property recursively, applying callback until \n    * callback returns a non-false value.\n    * \n    * @param {object} obj      \n    * @param {string} propName          The property name of the array to bubble up\n    * @param {function} fn              The test callback to be applied to each object\n    * @param {array} breadcrumb         The breadcrumb through the chain of the first match\n    * @returns {mixed}\n    */\n    ,search_obj_recursively : function(obj,propName,fn,breadcrumb){\n      \n        if(typeof breadcrumb === 'undefined'){\n            breadcrumb = [obj.id];\n        }\n      \n        var r1;\n        \n        for(var i in obj[propName]){\n\n            //RUN TEST\n            r1 = fn(obj[propName][i]);\n            \n            if(r1 !== false){\n            //MATCH RETURNED. RECURSE INTO MATCH IF HAS PROPERTY OF SAME NAME TO SEARCH\n                //CHECK THAT WE AREN'T CAUGHT IN A CIRCULAR LOOP\n                if(breadcrumb.indexOf(r1) !== -1){\n                    return public.debug([\n                        \"Circular condition in recursive search of obj property '\"\n                            +propName+\"' of object \"\n                            +((typeof obj.id !== 'undefined') ? \"'\"+obj.id+\"'\" : '')\n                            +\". Offending value: \"+r1\n                        ,(function(){\n                            breadcrumb.push(r1);\n                            return breadcrumb.join(\" [depends on]=> \");\n                        })()\n                    ]);\n                }\n                \n                breadcrumb.push(r1);\n\n                if(obj[propName][i][propName]){\n                    return private.deferred.search_obj_recursively(obj[propName][i],propName,fn,breadcrumb);\n                }\n                \n                break;\n            }\n\n        }\n\n        return breadcrumb;\n    }\n    \n    \n    /**\n     * Converts a promise description into a promise.\n     * \n     * @param {type} obj\n     * @returns {undefined}\n     */\n    ,convert_to_promise : function(obj){\n \n        //IF ALREADY EXISTS, RETURN EXISTING\n        if(!obj.id){\n            if(obj.type === 'timer'){\n                obj.id = \"timer-\" + obj.timeout + \"-\"+public.i++;\n            }\n            else if(typeof obj.url === 'string'){\n                obj.id = obj.url.split(\"/\").pop();\n                //REMOVE .js FROM ID\n                if(obj.id.search(\".js\")!== -1){\n                    obj.id = obj.id.split(\".\");\n                    obj.id.pop();\n                    obj.id = obj.id.join(\".\");\n                }\n            }\n            else{\n                return public.debug([\"Dependency type '\"+obj.type+\"' requires id, but id undefined.\",obj]);\n            }\n        }\n\n        if(obj.type !== 'timer'){\n            //RETURN THE PROMISE IF IT ALREADY EXISTS\n            if(typeof public.list[obj.id] !== 'undefined'){\n                return public.list[obj.id];\n            }\n        }\n\n        //CONVERT DEPENDENCY TO PROMISE\n        var prom;\n        switch(true){\n\n            //EVENT\n            case(obj.type === 'event'):\n                prom = private.deferred._wrap_event(obj);\n                break;\n\n            //ALREADY A PROMISE\n            case(obj.type === 'deferred'):\n            case(obj.type === 'promise' || obj.then):   \n\n                switch(true){\n                    \n                    //OBJECT IS A REFERENCE TO A PROMISE\n                    case(typeof obj.id === 'string'):\n                        console.warn(\"Promise '\"+obj.id +\"': did not exist. Auto creating new deferred.\");\n                        prom = public.deferred({\n                            id : obj.id\n                        });\n                        break;\n                    \n                    //OBJECT PROPERTY .promise EXPECTED TO RETURN A PROMISE\n                    case(typeof obj.promise === 'function'):\n                        if(obj.scope){\n                            prom = obj.promise.call(obj.scope);\n                        }\n                        else{\n                            prom = obj.promise();\n                        }\n                        break;\n                        \n                    //OBJECT IS A PROMISE\n                    case(obj.then):\n                        prom = obj;\n                        break;\n                        \n                    default:\n                        \n                }\n\n                //MAKE SURE IS PROMISE\n                if(typeof prom !== 'object' || !prom.then){\n                    return public.debug(\"Dependency labeled as a promise did not return a promise.\",obj);\n                }\n                break;\n\n            case(obj.type === 'timer'):\n                prom = private.deferred._wrap_timer(obj);\n                break;\n\n            //XHR\n            default:\n                obj.type = obj.type || \"default\";\n                prom = private.deferred._wrap_xhr(obj);\n        }\n        \n        //INDEX PROMISE BY ID FOR FUTURE REFERENCING\n        public.list[obj.id] = prom;\n\n        return prom;\n    }\n    \n    \n    /**\n     * Converts a reference to a DOM event to a promise.\n     * Resolved on first event trigger.\n     * \n     * @todo remove jquery dependency\n     * \n     * @param {object} obj\n     * @returns {object} deferred object\n     */\n    ,_wrap_event : function(obj){\n\n        var def = public.deferred({\n            id : obj.id\n        });\n\n        //BROWSER\n        if(typeof document !== 'undefined' && typeof window !== 'undefined'){\n            \n            if(typeof $ !== 'function'){\n                var msg = 'window and document based events depend on jQuery';\n                def.reject(msg);\n            }\n            else{\n                //For now, depend on jquery for IE8 DOMContentLoaded polyfill\n                switch(true){\n                    case(obj.id === 'ready' || obj.id === 'DOMContentLoaded'):\n                        $(document).ready(function(){\n                            def.resolve(1);\n                        });\n                        break;\n                    case(obj.id === 'load'):\n                        $(window).load(function(){\n                            def.resolve(1);\n                        });\n                        break;\n                    default:\n                        $(document).on(obj.id,\"body\",function(){\n                            def.resolve(1);\n                        });\n                }\n            }\n        }\n\n        return def;\n    }\n    \n\n    ,_wrap_timer : function(obj){\n\n        var prom = public.deferred(obj);\n        \n        (function(prom){\n            \n            var _start = new Date().getTime();      \n            setTimeout(function(){\n                var _end = new Date().getTime();\n                prom.resolve({\n                    start : _start\n                    ,end : _end\n                    ,elapsed : _end - _start\n                    ,timeout : obj.timeout\n                });\n            },obj.timeout);\n            \n        }(prom));\n        \n        return prom;\n    }\n    \n    \n    /**\n     * Creates a deferred object that depends on the loading of a file.\n     * \n     * @param {object} obj\n     * @returns {object} deferred object\n     */\n    ,_wrap_xhr : function(dep){\n        \n        \n        var required = [\"id\",\"url\"];\n        for(var i in required){\n            if(!dep[required[i]]){\n                return public.debug([\n                    \"File requests converted to promises require: \" + required[i]\n                    ,\"Make sure you weren't expecting dependency to already have been resolved upstream.\"\n                    ,dep\n                ]\n                );\n            }\n        }\n\n        \n        //IF PROMISE FOR THIS URL ALREADY EXISTS, RETURN IT\n        if(public.list[dep.id]){\n            return public.list[dep.id];\n        }\n        \n\n        //CONVERT TO DEFERRED:\n        var deferred;\n        deferred = public.deferred(dep);\n        deferred = private.deferred.attach_xhr(deferred,dep);\n        return deferred;\n    }\n    \n    \n    /**\n     *    \n     * \n     * @param {type} deferred\n     * @param {type} dep\n     * \n     * dep:\n     * =========\n     *                  \n     * <fs> boolean. Filesystem. Whether to loda the file from server filesytem or via http server\n     *                  \n     * @returns {unresolved}\n     */\n    ,attach_xhr : function(deferred,dep){\n\n        //GET AUTOPATH\n        if(dep.url[0] === \"*\"){\n                \n            var autopath = Orgy.config().autopath;\n            \n            if(typeof autopath !== 'string'){\n                public.debug([\n                        \"config.autopath must be set to a string.\"\n                    ]\n                    ,[\n                        \"When a dependency url begins with *, it is replaced by the config property 'autopath'.\"\n                ]);\n            }\n            else{\n                dep.url = dep.url.replace(/\\*/,autopath);\n            }\n        }\n        \n        \n        //BROWSER\n        if(typeof process !== 'object' || process + '' !== '[object process]'){\n            \n            this.head = this.head || document.getElementsByTagName(\"head\")[0] || document.documentElement;\n\n            switch(true){\n\n                case(dep.type==='script'):\n\n                    var node = document.createElement(\"script\");\n                    node.type = 'text/javascript';\n                    node.setAttribute(\"src\",dep.url);\n                    node.setAttribute(\"id\",dep.id);\n                    \n                    (function(node,dep,deferred){\n\n                        node.onload = node.onreadystatechange = function(){\n                            //Do not autoresolve modules, which are\n                            //self-resolved via Orgy.export\n                            if(!deferred._is_orgy_module){\n                                deferred.resolve((typeof node.value !== 'undefined') ? node.value : node)\n                            }\n                        };\n                        node.onerror = function(){\n                            deferred.reject(\"Failed to load path: \" + dep.url);\n                        };\n                    }(node,dep,deferred))\n                    \n                    //put scripts before <base> elements, after <meta>\n                    this.head.appendChild(node);\n                    break;\n                    \n                case(dep.type==='css' || dep.type==='link'):\n\n                    var node = document.createElement(\"link\");\n                    node.setAttribute(\"href\",dep.url);\n                    node.setAttribute(\"type\",\"text/css\");\n                    node.setAttribute(\"rel\",\"stylesheet\");\n                    \n                    if(node.onload){\n                        (function(node,dep,deferred){\n                            node.onload = node.onreadystatechange = function(){\n                               deferred.resolve(node);\n                           };\n\n                           node.onerror = function(){\n                               deferred.reeject(\"Failed to load path: \" + dep.url);\n                           }\n\n                        }(node,dep,deferred));\n                        \n                        this.head.appendChild(node);\n                        break;\n                    }\n                    else{\n                        //ADD NODE BUT MAKE XHR REQUEST TO CHECK FILE RECEIVED\n                        this.head.appendChild(node);\n                    }\n\n                case(dep.type==='json'):\n                default:\n                    \n                    var r;\n                    var req = new XMLHttpRequest();\n                    req.open('GET', dep.url, true);\n\n                    if(typeof dep.show_messages !== 'undefined'){\n                        req.setRequestHeader('show-messages', dep.show_messages);\n                    }\n                    if(typeof dep.return_packet !== 'undefined'){\n                        req.setRequestHeader('return-packet', dep.return_packet);\n                    }\n\n                    (function(dep,deferred){\n                        req.onreadystatechange = function() {\n                            if (req.readyState === 4) {\n                                if(req.status === 200){\n                                    r = req.responseText;\n                                    if(dep.type === 'json'){\n                                        try{\n                                            r = JSON.parse(r);\n                                        }\n                                        catch(e){\n                                            public.debug([\"Could not decode JSON\",dep.url,r]);\n\n                                        }\n                                    }\n                                    //WE WANT TO RESOLVE WITH DOM NODE FOR CSS FILES\n                                    deferred.resolve(node || r);\n                                }\n                                else{\n                                    deferred.reject(\"Error loading \"+dep.url);\n                                }\n                            }\n                        };\n                    }(dep,deferred));\n\n                    req.send(null);\n            }\n        }\n        //NODEJS\n        else{\n\n            function process_result(deferred,data,dep){\n\n                switch(true){\n\n                    case(dep.type === 'json'):\n                        data = JSON.parse(data);\n                        deferred.resolve(data);\n                        break;\n                        \n                    default:\n                        deferred.resolve(data);\n                        \n                }\n            }     \n            \n            if(dep.remote){\n                var request = require('request');\n                request.get(dep.url, function (error, response, body) {\n                    if (!error && response.statusCode == 200) {\n                        process_result(deferred,body,dep);\n                    }\n                });\n\n            }\n            else{\n                \n                //DON'T GET SCRIPTS AS TEXT\n                if(dep.type === 'script'){\n                    var data = require(dep.url);\n                    \n                    if(!deferred._is_orgy_module){\n                        deferred.resolve(data);\n                    }\n                }\n                //DON'T GET CSS, JUST ADD NODE\n                else if(dep.type === 'css'){\n                    \n                    if(private.config.document !== null){\n                        var node = private.config.document('head').append('<link rel=\"stylesheet\" href=\"'+dep.url+'\" type=\"text/css\" />');\n                        deferred.resolve(node);\n                    }\n                    else{\n                        return public.debug([dep.url,\"Must pass html document to Orgy.config() before attempting to add DOM nodes [i.e. css] as dependencies.\"]);\n                    }\n                }\n                else{\n                    \n                    var fs = require('fs');\n\n                    (function(deferred,dep){\n                        \n                        fs.readFile(dep.url, 'utf8', function (err, data) {\n\n                            if (err){\n                                public.debug([\"File \" + dep.url + \" not found @ local dep.url '\" + dep.url +\"'\",\"CWD: \"+process.cwd()]);\n                                process.exit();\n                            }\n\n                            process_result(deferred,data,dep);\n                        });\n\n                    }(deferred,dep));\n                    \n                }\n                \n            }\n\n        }\n        \n        return deferred;\n    }\n};","public.queue = function(deps,options){\n\n    var _o;\n    if(!(deps instanceof Array)){\n        return public.debug(\"Queue dependencies must be an array.\");\n    }\n    \n    if(!options || !options.id){\n        return public.debug(\"Queues require an id.\");\n    }\n    \n    //DOES NOT ALREADY EXIST\n    if(!public.list[options.id]){\n        \n        //CREATE NEW QUEUE OBJECT\n        var _o = private.queue.factory(options);\n\n        //ACTIVATE QUEUE\n        _o = private.queue.activate(_o,options,deps);\n\n    }\n    //ALREADY EXISTS\n    else {\n        \n        _o = public.list[options.id];\n        \n        if(_o.model !== 'queue'){\n        //MATCH FOUND BUT NOT A QUEUE, UPGRADE TO ONE\n\n            options.overwritable = 1;\n\n            _o = private.queue.upgrade(_o,options,deps);\n        }\n        else{\n            \n            //OVERWRITE ANY EXISTING OPTIONS\n            for(var i in options){\n                _o[i] = options[i];\n            }\n            \n            //ADD ADDITIONAL DEPENDENCIES IF NOT RESOLVED\n            if(deps.length > 0){\n                private.queue.tpl.add.call(_o,deps);\n            }\n            \n        }\n        \n        //RESUME RESOLUTION UNLESS SPECIFIED OTHERWISE\n        _o.halt_resolution = (typeof options.halt_resolution !== 'undefined') ?\n        options.halt_resolution : 0;\n    }\n    \n    return _o;\n};\n\n\nprivate.queue = {\n    \n    \n    factory : function(options){\n\n        //CREATE A NEW QUEUE OBJECT\n        var _o = public.naive_cloner([\n            private.deferred.tpl\n            ,private.queue.tpl\n            ,options\n        ]);\n\n        //YOU NOW HAVE A QUEUE OBJECT THAT IS INACTIVE ON THE OrgyLIST\n        return _o;\n    }    \n    \n    \n    /**\n     * Template object for all queues\n     * \n     * @type object\n     */\n    ,tpl : {\n        \n        model : 'queue'\n\n\n        //SET TRUE AFTER RESOLVER FIRED\n        ,resolver_fired : 0\n\n\n        //PREVENTS A QUEUE FROM RESOLVING EVEN IF ALL DEPENDENCIES MET\n        //PURPOSE: PREVENTS QUEUES CREATED BY ASSIGNMENT FROM RESOLVING \n        //BEFORE THEY ARE FORMALLY INSTANTIATED\n        ,halt_resolution : 0\n        \n\n        //USED TO CHECK STATE, ENSURES ONE COPY\n        ,upstream : {}\n        \n        \n        //USED RETURN VALUES, ENSURES ORDER\n        ,dependencies : []\n\n\n        ///////////////////////////////////////////////////\n        //  PUBLIC METHODS\n        ///////////////////////////////////////////////////\n\n\n        /**\n         * Add list of dependencies to a queue's upstream array.\n         * \n         * The queue will resolve once all the promises in its \n         * upstream array are resolved.\n         * \n         * When public.config.debug == 1, method will test each dependency is not\n         * previously scheduled to resolve downstream from the target, in which \n         * case it would never resolve because its upstream depends on it.\n         * \n         * @param {array} array of dependencies to add\n         * @returns {array} upstream\n         */\n        ,add : function(arr){\n\n            try{\n                if(arr.length === 0) return this.upstream;\n            }\n            catch(err){\n                public.debug(err);\n            }\n\n            //IF NOT PENDING, DO NOT ALLOW TO ADD\n            if(this._state !== 0){\n                return public.debug(\"Cannot add list to queue id:'\"+this.id\n                +\"'. Queue settled/in the process of being settled.\");\n            }\n\n            for(var a in arr){\n                \n                switch(true){\n\n                    //CHECK IF EXISTING PROMISE\n                    case(typeof public.list[arr[a]['id']] === 'object'):\n                        arr[a] = public.list[arr[a]['id']];\n                        break;\n\n                    //IF NOT, ATTEMPT TO CONVERT IT TO A PROMISE\n                    case(typeof arr[a] === 'object' && typeof arr[a].then !== 'function'):\n                        arr[a] = private.deferred.convert_to_promise(arr[a]);\n                        break;\n\n                    //REF IS A PROMISE.\n                    case(typeof arr[a].then === 'function'):\n                        break;\n\n                    default:\n                        console.error(\"Object could not be converted to promise.\");\n                        console.error(arr[a]);\n                        debugger;\n                        continue;\n                }\n\n                //must check the target to see if the dependency exists in its downstream\n                for(var b in this.downstream){\n                    if(b === arr[a].id){\n                        return public.debug(\"Error adding upstream dependency '\"+arr[a].id+\"' to queue\"+\" '\"+this.id+\"'.\\n Promise object for '\"+arr[a].id+\"' is scheduled to resolve downstream from queue '\"+this.id+\"' so it can't be added upstream.\");\n                    }\n                }\n\n                //ADD TO UPSTREAM, DOWNSTREAM, DEPENDENCIES\n                this.upstream[arr[a].id] = arr[a];\n                arr[a].downstream[this.id] = this;\n                this.dependencies.push(arr[a]);\n\n            }\n\n            return this.upstream;\n        }\n\n\n        /**\n         * Remove list from a queue.\n         * \n         * @param {array} arr\n         * @returns {array} array of list the queue is upstream\n         */\n        ,remove : function(arr){\n\n            //IF NOT PENDING, DO NOT ALLOW REMOVAL\n            if(this._state !== 0){\n                console.error(\"Cannot remove list from queue id:'\"+this.id+\"'. Queue settled/in the process of being settled.\");\n                return false;\n            }\n\n            for(var a in arr){\n                if(this.upstream[arr[a].id]){\n                    delete this.upstream[arr[a].id];\n                    delete arr[a].downstream[this.id];\n                }\n            }\n        }\n\n\n        /**\n         * Resets an existing,settled queue back to Orgying state.\n         * Clears out the downstream.\n         * Fails if not settled.\n         * \n         * @returns {obj}\n         */\n        ,reset : function(options){\n\n            if(this.settled !== 1 || this._state !== 1){\n                public.debug(\"Can only reset a queue settled without errors.\");\n            }\n\n            options = options || {};\n\n            this.settled = 0;\n            this._state = 0; \n            this.resolver_fired = 0;\n            this.done_fired = 0;\n\n            //REMOVE AUTO TIMEOUT TIMER\n            if(this._timeout_id){\n                clearTimeout(this._timeout_id);\n            }\n            \n            //CLEAR OUT THE DOWNSTREAM\n            this.downstream = {};\n            this.dependencies = [];\n\n            //SET NEW AUTO TIMEOUT\n            private.deferred.auto_timeout.call(this,options.timeout);\n\n            //POINTLESS - WILL JUST IMMEDIATELY RESOLVE SELF\n            //this.check_self()\n\n            return this;\n        }\n        \n        \n        /**\n         * Cauaes a queue to look over its dependencies and see if it \n         * can be resolved.\n         * \n         * This is done automatically by each dependency that loads,\n         * so is not needed unless:\n         * \n         * -debugging\n         * \n         * -the queue has been reset and no new\n         * dependencies were since added.\n         * \n         * @returns {int} State of the queue.\n         */\n        ,check_self : function(){\n            private.queue.receive_signal(this,this.id);\n            return this._state;\n        }\n    }\n    \n    \n    ///////////////////////////////////////////////////\n    //  PRIVATE METHODS\n    ///////////////////////////////////////////////////\n    \n    \n    /**\n     * Activates a queue object.\n     * \n     * @param {object} o\n     * @param {object} options\n     * @param {array} deps\n     * @returns {object} queue\n     */\n    ,activate : function(o,options,deps){\n        \n        //ACTIVATE AS A DEFERRED\n        o = private.deferred.activate(o);\n\n        //ADD ANY DEFERREDS TO QUEUE\n        private.queue.tpl.add.call(o,deps);\n\n        //SEE IF CAN BE IMMEDIATELY RESOLVED BY CHECKING UPSTREAM\n        private.queue.receive_signal(o,o.id);\n        \n        //ASSIGN THIS QUEUE UPSTREAM TO OTHER QUEUES\n        if(o.assign){\n            for(var a in o.assign){\n                public.assign(o.assign[a],[o],true);\n            }\n        }\n        \n        return o;\n    }\n    \n    \n    /**\n    * A \"signal\" here causes a queue to look through each item in its upstream and \n    * check to see if all are resolved. \n    * \n    * Signals can only be received by a queue itself or a promise/deferred/queue\n    * in its upstream.\n    * \n    * @param {string} from_id\n    * @returns {void}\n    */\n    ,receive_signal : function(target,from_id){\n\n        if(target.halt_resolution === 1) return;\n\n       //MAKE SURE THE SIGNAL WAS FROM A PROMISE BEING LISTENED TO\n       //BUT ALLOW SELF STATUS CHECK\n       if(from_id !== target.id && !target.upstream[from_id]){\n           console.error(from_id + \" can't signal \" + target.id + \" because not in upstream.\");\n           debugger;\n           return;\n       }\n       //RUN THROUGH QUEUE OF OBSERVING PROMISES TO SEE IF ALL DONE\n       else{\n           var status = 1;\n           for(var i in target.upstream){\n               //SETS STATUS TO 0 IF ANY OBSERVING HAVE FAILED, BUT NOT IF PENDING OR RESOLVED\n               if(target.upstream[i]._state !== 1) {\n                   status = target.upstream[i]._state;\n                   break;\n               }\n           }\n       }\n\n       //RESOLVE QUEUE IF UPSTREAM FINISHED\n       if(status === 1){\n           \n            //GET RETURN VALUES PER DEPENDENCIES, WHICH SAVES ORDER AND \n            //REPORTS DUPLICATES\n            var values = [];\n            for(var i in target.dependencies){\n                values.push(target.dependencies[i].value);\n            }\n\n            private.deferred.tpl.resolve.call(target,values);\n       }\n\n       if(status === 2){\n           var err = [\n               target.id+\" dependency '\"+target.upstream[i].id + \"' was rejected.\"\n               ,target.upstream[i].arguments\n           ];\n           private.deferred.tpl.reject.apply(target,err);\n       }\n    }\n\n\n    /**\n    * Upgrades a promise object to a queue.\n    * \n    * @param {object} prom\n    * @param {object} options\n    * @param {array} dependencies\n    * @returns {object} queue object\n    */\n    ,upgrade : function(obj,options,deps){\n\n        if(obj.settled !== 0 || (obj.model !== 'promise' && obj.model !== 'deferred')){\n            return public.debug('Can only upgrade unsettled promise or deferred into a queue.');\n        }\n        \n       //GET A NEW QUEUE OBJECT AND MERGE IN\n        var _o = public.naive_cloner([\n            private.queue.tpl\n            ,options\n        ]);\n        \n        for(var i in _o){\n           obj[i] = _o[i];\n        }\n        \n        delete _o;\n\n        //CREATE NEW INSTANCE OF QUEUE\n        obj = private.queue.activate(obj,options,deps);\n\n        //RETURN QUEUE OBJECT\n        return obj;\n    }\n    \n};","public.cast = function(obj){\n            \n    var required = [\"then\",\"error\",\"id\"];\n    for(var i in required){\n        if(!obj[required[i]]){\n            return public.debug(\"Castable objects require: \" + required[i]);\n        }\n    }\n\n    //GET A BLANK DEFERRED TO PLAY WITH\n    var deferred = public.deferred({\n        id : obj.id\n    });\n\n    //CREATE RESOLVER [ASYNC]\n    var resolver = function(){\n        deferred.resolve.call(deferred,arguments[0]);\n    };\n\n    //SET RESOLVER\n    obj.then(resolver);\n\n    //CREATE REJECTOR [ASYNC]\n    var err = function(err){\n        deferred.reject(err);\n    };\n\n    //SET REJECTOR\n    obj.error(err);\n\n    //RETURN THE DEFERRED\n    return deferred;\n}\n        ","if(typeof process === 'object' && process + '' === '[object process]'){\n    // is node\n    module.exports = public;\n}\nelse{\n    // not node\n    Orgy = public;\n}"]}