{"version":3,"file":"orgy.devel.js","sources":["?","../src/js/main.js","../src/js/deferred.js","../src/js/deferred.tpl.js","../src/js/queue.js","../src/js/cast.js","../src/js/build.js"],"names":["exports","global","public","private","list","modules_exported","modules_loaded","i","config","autopath","document","debug_mode","cwd","mode","process","hooks","timeout","obj","define","id","data","options","def","dependencies","resolver","debug","settled","backtrace","get_backtrace_info","Array","deps","queue","deferred","autoresolve","resolve","get","assign","tgt","arr","add","q","then","this","model","remove","naive_cloner","donors","o","a","b","slice","JSON","parse","stringify","e","console","error","msg","log","stack","exit","ss","r","l","str","Error","split","trim","pop","search","length","window","location","protocol","match","origin","_o","factory","activate","tpl","settle","timeout_id","clearTimeout","set_state","onSettle","callbacks","onComplete","train","push","d2","itinerary","last","caboose","run_train","done","pause_on_deferred","value","param","onBefore","shift","execution_history","call","thenables","fn","t","int","state","signal_downstream","get_state","overwritable","auto_timeout","onActivate","type","scope","setTimeout","auto_timeout_cb","msgs","search_obj_recursively","reject","cb","reject_q","target","downstream","receive_signal","propName","breadcrumb","r1","indexOf","join","convert_to_promise","parent","url","_wrap_event","warn","promise","_wrap_timer","_wrap_xhr","$","ready","load","on","prom","_start","Date","getTime","_end","start","end","elapsed","dep","required","attach_xhr","substring","head","getElementsByTagName","documentElement","node","createElement","setAttribute","onload","onreadystatechange","onerror","appendChild","reeject","req","XMLHttpRequest","open","show_messages","setRequestHeader","return_packet","readyState","status","responseText","send","process_result","remote","request","require","response","body","statusCode","owd","dirchanged","chdir","path","append","fs","readFile","err","done_fired","callback_states","resolver_fired","unshift","rejector","fn2","halt_resolution","upstream","reset","check_self","upgrade","from_id","values","arguments","apply","cast","module","Orgy"],"mappings":"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","sourcesContent":[null,"var public = {};\nvar private = {};\n\n\n////////////////////////////////////////\n//  PUBLIC VARIABLES\n////////////////////////////////////////\n\n\n/**\n * A directory of all promises, deferreds, and queues.\n * @type object\n */\npublic.list = {};\n\n\n/**\n * Array of all exported modules\n * @type Array\n */\npublic.modules_exported = [];\n\n\n/**\n * Index number of last module loaded in public.modules_exported\n * @type Number\n */\npublic.modules_loaded = 0;\n\n\n/**\n * iterator for ids\n * @type integer\n */\npublic.i = 0;\n\n\n////////////////////////////////////////\n//  PRIVATE VARIABLES\n////////////////////////////////////////\n\n\n/**\n * Configuration values.\n * \n * @type object\n */\nprivate.config = {\n    \n    autopath : ''\n    ,document : null\n    ,debug_mode : 0\n    //set the current working directory of the callee script,\n    //because node has no constant for this\n    ,cwd : false\n    ,mode : (function(){\n        if(typeof process === 'object' && process + '' === '[object process]'){\n            // is node\n            return \"node\";\n        }\n        else{\n            // not node\n            return \"browser\";\n        }\n    }())\n    /**\n     * - onActivate /when each instance activated\n     * - onSettle   /when each instance settles\n     * \n     * @type object\n     */\n    ,hooks : {\n    }\n    ,timeout : 5000 //default timeout\n};\n\n\n////////////////////////////////////////\n//  PUBLIC METHODS\n////////////////////////////////////////\n\n\n/**\n * Configuration setter.\n * \n * @param {object} obj\n * @returns {object}\n */\npublic.config = function(obj){\n    \n    if(typeof obj === 'object'){\n        for(var i in obj){\n          private.config[i] = obj[i];\n        }\n    }\n    \n    return private.config;\n};\n\n\n/**\n* Creates a new promise from a value and an id and automatically \n* resolves it.\n* \n* @param {string} id\n* @param {mixed} data\n* @param {object} options\n* @returns {object} resolved promise\n*/\npublic.define = function(id,data,options){\n\n    var def;\n    options = options || {};\n    options.dependencies = options.dependencies || null;\n    options.resolver = options.resolver || null;\n    \n    //test for a valid id\n    if(typeof id !== 'string'){\n      public.debug(\"Must set id when defining an instance.\");\n    }\n    \n    //Check no existing instance defined with same id\n    if(public.list[id] && public.list[id].settled === 1){\n      return public.debug(\"Can't define \" + id + \". Already resolved.\");\n    }\n    \n    options.id = id;\n    \n    //Set backtrace info, here - so origin points to callee\n    options.backtrace = private.get_backtrace_info('public.define');\n         \n    if(options.dependencies !== null \n      && options.dependencies instanceof Array){\n      //Define as a queue - can't autoresolve because we have deps\n      var deps = options.dependencies;\n      delete options.dependencies;\n      def = public.queue(deps,options);\n    }\n    else{\n      //Define as a deferred\n      def = public.deferred(options);\n\n      //Try to immediately settle [define]\n      if(options.resolver === null \n        && (typeof options.autoresolve !== 'boolean' \n        || options.autoresolve === true)){\n        //prevent future autoresove attempts [i.e. from xhr response]\n        def.autoresolve = false;\n        def.resolve(data);\n      }\n    }\n    \n    return def;\n};\n\n\n/**\n * Getter.\n * \n * @param {string} id\n * @returns {object}\n */\npublic.get = function(id){\n  if(public.list[id]){\n    return public.list[id];\n  }\n  else{\n    return public.debug([\n      \"No instance exists: \"+id\n    ]);\n  }\n};\n\n\n/**\n * Add/remove an upstream dependency to/from a queue. \n * \n * Can use a queue id, even for a queue that is yet to be created.\n * \n * @param {string} tgt | queue / queue id\n * @param {array}  arr | list/promise ids,dependencies\n * @param {boolean} add | add if true, remove if false\n * \n * @return {array} queue of list\n */\npublic.assign = function(tgt,arr,add){\n\n    add = (typeof add === \"boolean\") ? add : 1;\n\n    var id,q;\n    switch(true){\n        case(typeof tgt === 'object' && typeof tgt.then === 'function'):\n            id = tgt.id;\n            break;\n        case(typeof tgt === 'string'):\n            id = tgt;\n            break;\n        default:\n            return public.debug(\"Assign target must be a queue object or the id of a queue.\",this);\n    }\n\n    //IF TARGET ALREADY LISTED\n    if(this.list[id] && this.list[id].model === 'queue'){\n        q = this.list[id];\n        \n        //=> ADD TO QUEUE'S UPSTREAM\n        if(add){\n            q.add(arr);\n        }\n        //=> REMOVE FROM QUEUE'S UPSTREAM\n        else{\n            q.remove(arr);\n        }\n    }\n    //CREATE NEW QUEUE AND ADD DEPENDENCIES\n    else if(add){\n\n        q = public.queue(arr,{\n            id : id\n        });\n    }\n    //ERROR: CAN'T REMOVE FROM A QUEUE THAT DOES NOT EXIST\n    else{\n        return public.debug(\"Cannot remove dependencies from a queue that does not exist.\",this);\n    }\n\n    return q;\n};\n\n\n/**\n * Makes a shallow copy of an array. \n * Makes a copy of an object so long as it is JSON\n * \n * @param {array} donors /array of donor objects, \n *                overwritten from right to left\n * @returns {object}\n */\npublic.naive_cloner = function(donors){\n    var o = {};\n    for(var a in donors){\n        for(var b in donors[a]){\n            if(donors[a][b] instanceof Array){\n                o[b] = donors[a][b].slice(0);\n            }\n            else if(typeof donors[a][b] === 'object'){\n              try{\n                o[b] = JSON.parse(JSON.stringify(donors[a][b]));\n              }\n              catch(e){\n                console.error(e);\n                debugger;\n              }\n            }\n            else{\n                o[b] = donors[a][b];\n            }\n        }\n    }\n    return o;\n};\n        \n\n/**\n * Debugging method.\n * \n * @param {string|array} msg\n * @param {object} def\n * @returns {Boolean}\n */\npublic.debug = function(msg,def){\n    \n    if(! (msg instanceof Array)){\n        msg = [msg];\n    }\n\n    for(var i in msg){\n        if(typeof msg[i] === 'string'){\n            console.error(\"ERROR-\"+i+\": \"+msg[i]);\n        }\n        else{\n            console.error(msg[i]);\n        }\n    }\n\n    //if we saved a stack trace to connect async, push it\n    if(def){\n        console.log(\"Backtrace:\");\n        console.log(def.backtrace.stack);\n    }\n    \n    if(private.config.debug_mode){\n      //turn off debug_mode to avoid hitting debugger\n      debugger;\n    }\n    \n    if(private.config.mode === 'browser'){\n        return false;\n    }\n    else{\n        process.exit();\n    }\n};\n\n\n////////////////////////////////////////\n//  PUBLIC METHODS\n////////////////////////////////////////\n\n\nprivate.get_backtrace_info = function(ss){\n\n    //Origin is the call immediately preceding\"ss\"\n          \n    var r = {}\n    ,l\n    ,str;\n    \n    l = r.stack = new Error().stack;\n    \n    if(private.config.mode === 'browser'){\n      l = l.split(ss)[1].trim().split(\"\\n\");\n      str = l.pop();\n      while(str.search(\"orgy\") !== -1 && l.length > 0){\n        //iterate until outside of class\n        str = l.pop();\n      }\n      str = window.location.protocol + \"//\" + str.split(\"//\")[1];\n    }\n    else{\n      str = l.split(ss + \" \")[1].split(\"\\n\")[1];\n      str = str.match(/\\(([^)]+)\\)/)[1];\n    }\n\n    //Set origin\n    r.origin = str;\n    \n    return r;\n};","/**\n * Deferred class.\n * \n */\n\nprivate.deferred = {};\n\n\n//////////////////////////////////////////\n//  PUBLIC VARIABLES\n//////////////////////////////////////////\n\n\n//////////////////////////////////////////\n//  PRIVATE VARIABLES\n//////////////////////////////////////////\n\n\n//////////////////////////////////////////\n//  PUBLIC METHODS\n//////////////////////////////////////////\n\n\n/**\n * Creates a new deferred object. \n * \n * @param {object} options\n *          {string}  id  /Optional. Use the id with Orgy.get(id). Defaults to line number of instantiation, plus an iterator.\n *          {number} timeout /time in ms after which reject is called. Defaults to Orgy.config().timeout [5000]. Note the timeout is only affected by dependencies and/or the resolver callback. Then,done delays will not flag a timeout because they are called after the instance is considered resolved.\n * @returns {object}\n */\npublic.deferred = function(options){\n    \n    options = options || {};\n    \n    if(options.id && public.list[options.id]){\n        _o = public.list[options.id];\n    }\n    else{\n        //CREATE NEW INSTANCE OF DEFERRED CLASS\n        var _o = private.deferred.factory(options);\n\n        //ACTIVATE DEFERRED\n        _o = private.deferred.activate(_o);\n    }\n    \n    return _o;\n};\n\n\n////////////////////////////////////////\n//  PRIVATE METHODS\n////////////////////////////////////////\n\n\nprivate.deferred.factory = function(options){\n        \n    var _o = public.naive_cloner([\n        private.deferred.tpl\n        ,options\n    ]);\n\n    //Get backtrace info if none found [may be set @ public.define]\n    if(!_o.backtrace){\n      _o.backtrace = private.get_backtrace_info('public.deferred');\n    }\n    \n    //if no id, use backtrace origin\n    if(!options.id){\n      _o.id = _o.backtrace.origin + '-' + (++public.i);\n    }\n    \n    return _o;\n};\n    \n\nprivate.deferred.settle = function(def){\n    \n    //REMOVE AUTO TIMEOUT TIMER\n    if(def.timeout_id){\n        clearTimeout(def.timeout_id);\n    }\n    \n    \n    //Set state to resolved\n    private.deferred.set_state(def,1);\n    \n    \n    //Call hook\n    if(private.config.hooks.onSettle){\n      private.config.hooks.onSettle(def);\n    }\n    \n    \n    //Add done as a callback to then chain completion.\n    def.callbacks.then.hooks.onComplete.train.push(function(d2,itinerary,last){\n        def.caboose = last;\n        \n        //Run done\n        private.deferred.run_train(\n            def\n            ,def.callbacks.done\n            ,def.caboose\n            ,{pause_on_deferred : false}\n        );\n\n    });\n    \n  \n    //Run then queue\n    private.deferred.run_train(\n        def\n        ,def.callbacks.then\n        ,def.value\n        ,{pause_on_deferred : true}\n    );\n    \n    \n    return def;\n};\n\n\n/**\n * Runs an array of functions sequentially as a partial function.\n * Each function's argument is the result of its predecessor function.\n * \n * By default, execution chain is paused when any function \n * returns an unresolved deferred. (pause_on_deferred) [OPTIONAL]\n * \n * @param {object} def  /deferred object\n * @param {object} obj  /itinerary\n *      train       {array}\n *      hooks       {object}    \n *          onBefore        {array}\n *          onComplete      {array}\n * @param {mixed} param /param to pass to first callback\n * @param {object} options\n *      pause_on_deferred   {boolean}\n *      \n * @returns {void}\n */\nprivate.deferred.run_train = function(def,obj,param,options){\n    \n    //allow previous return values to be passed down chain\n    var r = param || def.caboose || def.value;\n    \n    //onBefore event\n    if(obj.hooks && obj.hooks.onBefore.train.length > 0){\n        private.deferred.run_train(\n            def\n            ,obj.hooks.onBefore\n            ,param\n            ,{pause_on_deferred : false}\n        );\n    }\n    \n    while(obj.train.length > 0){\n        \n        //remove fn to execute\n        var last = obj.train.shift();\n        def.execution_history.push(last);\n  \n        //def.caboose needed for then chain declared after resolved instance\n        r = def.caboose = last.call(def,def.value,def,r);\n\n        //if result is an thenable, halt execution \n        //and run unfired arr when thenable settles\n        if(options.pause_on_deferred){\n            \n            //If r is an unsettled thenable\n            if(r && r.then && r.settled !== 1){\n\n                //execute rest of this train after r resolves\n                r.callbacks.resolve.hooks.onComplete.train.push(function(){\n\n                    private.deferred.run_train(\n                        def\n                        ,obj\n                        ,r\n                        ,{pause_on_deferred : true}\n                    );\n                });\n\n                //terminate execution\n                return;\n            }\n            \n            //If is an array than contains an unsettled thenable\n            else if(r instanceof Array){\n\n                var thenables = [];\n\n                for(var i in r){\n                    \n                    if(r[i].then && r[i].settled !== 1){\n                        \n                        thenables.push(r[i]);\n           \n                        var fn = (function(t,def,obj,param){\n                    \n                            return function(){\n      \n                                //Bail if any thenables unsettled\n                                for(var i in t){\n                                    if(t[i].settled !== 1){\n                                        return;\n                                    }\n                                }\n\n                                private.deferred.run_train(\n                                    def\n                                    ,obj\n                                    ,param\n                                    ,{pause_on_deferred : true}\n                                );\n                            };\n                            \n                        })(thenables,def,obj,param);\n                        \n                        //execute rest of this train after\n                        //all thenables found in r resolve\n                        r[i].callbacks.resolve.hooks.onComplete.train.push(fn);\n\n                        //terminate execution\n                        return;\n                    }\n                }\n            }\n        }\n    }\n    \n    //onComplete event\n    if(obj.hooks && obj.hooks.onComplete.train.length > 0){\n        private.deferred.run_train(def\n                                ,obj.hooks.onComplete\n                                ,r\n                                ,{pause_on_deferred : false});\n    }\n};\n\n\n/**\n * Sets the state of an Orgy object.\n * \n * @param {object} def\n * @param {number} int\n * @returns {void}\n */\nprivate.deferred.set_state = function(def,int){\n\n    def.state = int;\n\n    //IF RESOLVED OR REJECTED, SETTLE\n    if(int === 1 || int === 2){\n        def.settled = 1;\n    }\n\n    if(int === 1 || int === 2){\n        private.deferred.signal_downstream(def);\n    }\n};\n    \n   \n/**\n * Gets the state of an Orgy object\n * \n * @param {object} def\n * @returns {number} \n */\nprivate.deferred.get_state = function(def){\n    return def.state;\n};\n\n\nprivate.deferred.activate = function(obj){\n    \n    //MAKE SURE NAMING CONFLICT DOES NOT EXIST\n    if(public.list[obj.id] && !public.list[obj.id].overwritable){\n        public.debug(\"Tried to overwrite \"+obj.id+\" without overwrite permissions.\");\n        return public.list[obj.id];\n    }\n\n    //SAVE TO MASTER LIST\n    public.list[obj.id] = obj;\n\n    //AUTO TIMEOUT\n    private.deferred.auto_timeout.call(obj);\n\n    //Call hook\n    if(private.config.hooks.onActivate){\n      private.config.hooks.onActivate(obj);\n    }\n    \n    return obj;\n};\n\n\n/**\n * Sets the automatic timeout on a promise object.\n * \n * @param {integer} timeout (optional)\n * @returns {Boolean}\n */\nprivate.deferred.auto_timeout = function(timeout){\n\n    this.timeout = (typeof timeout === 'undefined') \n    ? this.timeout : timeout;\n\n    //AUTO REJECT ON timeout\n    if(!this.type || this.type !== 'timer'){\n\n        //DELETE PREVIOUS TIMEOUT IF EXISTS\n        if(this.timeout_id){\n            clearTimeout(this.timeout_id);\n        }\n\n        if(typeof this.timeout === 'undefined'){\n            public.debug([\n              \"Auto timeout this.timeout cannot be undefined.\"\n              ,this.id\n            ]);\n        }\n        else if (this.timeout === -1){\n            //NO AUTO TIMEOUT SET\n            return false;\n        }\n        var scope = this;\n\n        this.timeout_id = setTimeout(function(){\n            private.deferred.auto_timeout_cb.call(scope);\n        }, this.timeout);\n\n    }\n    else{\n        //@todo WHEN A TIMER, ADD DURATION TO ALL UPSTREAM AND LATERAL?\n    }\n    \n    return true;\n};\n\n\n/**\n * Callback for autotimeout. Declaration here avoids memory leak.\n * \n * @returns {void}\n */\nprivate.deferred.auto_timeout_cb = function(){\n\n    if(this.state !== 1){\n\n        //GET THE UPSTREAM ERROR ID\n        var msgs = [];\n        var scope = this;\n\n        var fn = function(obj){\n            if(obj.state !== 1){\n                return obj.id;\n            }\n            else{\n                return false;\n            }\n        };\n\n        /**\n         * Run over a given object property recursively, \n         * applying callback until \n         * callback returns a non-false value.\n         */\n        if(private.config.debug_mode){\n            var r = private.deferred.search_obj_recursively(this,'upstream',fn);\n            msgs.push(scope.id + \": rejected by auto timeout after \" \n                    + this.timeout + \"ms\");\n            msgs.push(\"Cause:\");\n            msgs.push(r);\n            return private.deferred.tpl.reject.call(this,msgs);\n        }\n        else{\n            return private.deferred.tpl.reject.call(this);\n        }\n    }\n};\n\n\nprivate.deferred.error = function(cb){\n\n    //IF ERROR ALREADY THROWN, EXECUTE CB IMMEDIATELY\n    if(this.state === 2){\n        cb();\n    }\n    else{\n        this.reject_q.push(cb);\n    }\n\n    return this;\n};\n\n\n/**\n * Signals all downstream promises that private promise object's state has changed.\n * \n * \n * @todo Since the same queue may have been assigned twice directly or \n * indirectly via shared dependencies, make sure not to double resolve\n * - which throws an error.\n *     \n * @param {object} target deferred/queue\n * @returns {void}\n */\nprivate.deferred.signal_downstream = function(target){\n\n    //MAKE SURE ALL DOWNSTREAM IS UNSETTLED\n    for(var i in target.downstream){\n        if(target.downstream[i].settled === 1){\n\n          if(target.downstream[i].state !== 1){\n            //tried to settle a rejected downstream\n            continue;\n          }\n          else{\n            //tried to settle a successfully settled downstream\n            public.debug(target.id + \" tried to settle promise \"+\"'\"+target.downstream[i].id+\"' that has already been settled.\");\n          }\n        }\n    }\n\n    //NOW THAT WE KNOW ALL DOWNSTREAM IS UNSETTLED, WE CAN IGNORE ANY\n    //SETTLED THAT RESULT AS A SIDE EFFECT TO ANOTHER SETTLEMENT\n    for (var i in target.downstream){\n        if(target.downstream[i].settled !== 1){\n            private.queue.receive_signal(target.downstream[i],target.id);\n        }\n    }\n};\n    \n    \n/**\n* Run over a given object property recursively, applying callback until \n* callback returns a non-false value.\n* \n* @param {object} obj      \n* @param {string} propName          The property name of the array to bubble up\n* @param {function} fn              The test callback to be applied to each object\n* @param {array} breadcrumb         The breadcrumb through the chain of the first match\n* @returns {mixed}\n*/\nprivate.deferred.search_obj_recursively = function(obj,propName,fn,breadcrumb){\n\n    if(typeof breadcrumb === 'undefined'){\n        breadcrumb = [obj.id];\n    }\n\n    var r1;\n\n    for(var i in obj[propName]){\n\n        //RUN TEST\n        r1 = fn(obj[propName][i]);\n\n        if(r1 !== false){\n        //MATCH RETURNED. RECURSE INTO MATCH IF HAS PROPERTY OF SAME NAME TO SEARCH\n            //CHECK THAT WE AREN'T CAUGHT IN A CIRCULAR LOOP\n            if(breadcrumb.indexOf(r1) !== -1){\n                return public.debug([\n                    \"Circular condition in recursive search of obj property '\"\n                        +propName+\"' of object \"\n                        +((typeof obj.id !== 'undefined') ? \"'\"+obj.id+\"'\" : '')\n                        +\". Offending value: \"+r1\n                    ,(function(){\n                        breadcrumb.push(r1);\n                        return breadcrumb.join(\" [depends on]=> \");\n                    })()\n                ]);\n            }\n\n            breadcrumb.push(r1);\n\n            if(obj[propName][i][propName]){\n                return private.deferred.search_obj_recursively(obj[propName][i],propName,fn,breadcrumb);\n            }\n\n            break;\n        }\n\n    }\n\n    return breadcrumb;\n};\n    \n    \n/**\n * Converts a promise description into a promise.\n * \n * @param {type} obj\n * @returns {undefined}\n */\nprivate.deferred.convert_to_promise = function(parent,obj){\n\n    //Return if instance already exists with this id\n    if(!obj.id){\n\n        if(obj.type === 'timer'){\n            obj.id = \"timer-\" + obj.timeout + \"-\" + (++public.i);\n        }\n        else if(typeof obj.url === 'string'){\n            obj.id = obj.url.split(\"/\").pop();\n            //REMOVE .js FROM ID\n            if(obj.id.search(\".js\")!== -1){\n                obj.id = obj.id.split(\".\");\n                obj.id.pop();\n                obj.id = obj.id.join(\".\");\n            }\n        }\n        else{\n            return public.debug([\n                \"Dependencies without a 'url' property require 'id' property be set.\"\n                ,\"'\"+obj.type+\"' id undefined.\"\n                ,obj\n            ]);\n        }\n    }\n\n    if(obj.type !== 'timer'){\n        //Return if already exists\n        if(typeof public.list[obj.id] !== 'undefined'){\n          //A previous promise of the same id exists. \n          //Make sure this dependency object doesn't have a\n          //resolver - if it does error\n          if(obj.resolver){\n            public.debug([\n              \"You can't set a resolver on a queue that has already been declared. You can only reference the original.\"\n              ,\"Detected re-init of '\" + obj.id + \"'.\"\n              ,\"Attempted:\"\n              ,obj\n              ,\"Existing:\"\n              ,public.list[obj.id]\n            ]);\n          }\n          else{\n            return public.list[obj.id];\n          }\n        }\n    }\n\n    //Convert dependency to an instance\n    var def;\n    switch(true){\n\n        //Event\n        case(obj.type === 'event'):\n            def = private.deferred._wrap_event(obj);\n            break;\n\n        case(obj.type === 'queue'):\n            def = public.queue(obj.dependencies,obj);\n            break;\n            \n        //Already an instance\n        case(obj.type === 'deferred'):\n        case(obj.type === 'promise' || obj.then):   \n\n            switch(true){\n\n                //Reference to an existing instance\n                case(typeof obj.id === 'string'):\n                    console.warn(\"'\"+obj.id +\"': did not exist. Auto creating new deferred.\");\n                    def = public.deferred({\n                        id : obj.id\n                    });\n                    break;\n\n                //OBJECT PROPERTY .promise EXPECTED TO RETURN A PROMISE\n                case(typeof obj.promise === 'function'):\n                    if(obj.scope){\n                        def = obj.promise.call(obj.scope);\n                    }\n                    else{\n                        def = obj.promise();\n                    }\n                    break;\n\n                //Object is a thenable\n                case(obj.then):\n                    def = obj;\n                    break;\n\n                default:\n\n            }\n\n            //Check if is a thenable\n            if(typeof def !== 'object' || !def.then){\n                return public.debug(\"Dependency labeled as a promise did not return a promise.\",obj);\n            }\n            break;\n\n        case(obj.type === 'timer'):\n            def = private.deferred._wrap_timer(obj);\n            break;\n\n        //Load file\n        default:\n            obj.type = obj.type || \"default\";\n            //Inherit parent's current working directory\n            if(parent.cwd){\n              obj.cwd = parent.cwd;\n            }\n            def = private.deferred._wrap_xhr(obj);\n    }\n\n    //Index promise by id for future referencing\n    public.list[obj.id] = def;\n\n    return def;\n};\n    \n    \n/**\n * Converts a reference to a DOM event to a promise.\n * Resolved on first event trigger.\n * \n * @todo remove jquery dependency\n * \n * @param {object} obj\n * @returns {object} deferred object\n */\nprivate.deferred._wrap_event = function(obj){\n\n    var def = public.deferred({\n        id : obj.id\n    });\n\n    //BROWSER\n    if(typeof document !== 'undefined' && typeof window !== 'undefined'){\n\n        if(typeof $ !== 'function'){\n            var msg = 'window and document based events depend on jQuery';\n            def.reject(msg);\n        }\n        else{\n            //For now, depend on jquery for IE8 DOMContentLoaded polyfill\n            switch(true){\n                case(obj.id === 'ready' || obj.id === 'DOMContentLoaded'):\n                    $(document).ready(function(){\n                        def.resolve(1);\n                    });\n                    break;\n                case(obj.id === 'load'):\n                    $(window).load(function(){\n                        def.resolve(1);\n                    });\n                    break;\n                default:\n                    $(document).on(obj.id,\"body\",function(){\n                        def.resolve(1);\n                    });\n            }\n        }\n    }\n\n    return def;\n};\n    \n\nprivate.deferred._wrap_timer = function(obj){\n\n    var prom = public.deferred(obj);\n\n    (function(prom){\n\n        var _start = new Date().getTime();      \n        setTimeout(function(){\n            var _end = new Date().getTime();\n            prom.resolve({\n                start : _start\n                ,end : _end\n                ,elapsed : _end - _start\n                ,timeout : obj.timeout\n            });\n        },obj.timeout);\n\n    }(prom));\n\n    return prom;\n};\n    \n    \n/**\n * Creates a deferred object that depends on the loading of a file.\n * \n * @param {object} dep\n * @returns {object} deferred object\n */\nprivate.deferred._wrap_xhr = function(dep){\n\n\n    var required = [\"id\",\"url\"];\n    for(var i in required){\n        if(!dep[required[i]]){\n            return public.debug([\n                \"File requests converted to promises require: \" + required[i]\n                ,\"Make sure you weren't expecting dependency to already have been resolved upstream.\"\n                ,dep\n            ]\n            );\n        }\n    }\n\n\n    //IF PROMISE FOR THIS URL ALREADY EXISTS, RETURN IT\n    if(public.list[dep.id]){\n        return public.list[dep.id];\n    }\n\n\n    //CONVERT TO DEFERRED:\n    var def;\n    def = public.deferred(dep);\n    def = private.deferred.attach_xhr(def,dep);\n    return def;\n};\n    \n    \n/**\n *    \n * \n * @param {type} deferred\n * @param {type} dep\n * \n * dep:\n * =========\n *                  \n * <fs> boolean. Filesystem. Whether to loda the file from server filesytem or via http server\n *                  \n * @returns {unresolved}\n */\nprivate.deferred.attach_xhr = function(deferred,dep){\n\n    //BROWSER\n    if(typeof process !== 'object' || process + '' !== '[object process]'){\n      \n      //replace node style './' with '/'\n      if(dep.url[0] === \".\" && dep.url[1] === \"/\"){\n        dep.url = dep.url.substring(1);\n      }\n\n      this.head = this.head || document.getElementsByTagName(\"head\")[0] || document.documentElement;\n\n      switch(true){\n\n            case(dep.type === 'script'):\n\n                var node = document.createElement(\"script\");\n                node.type = 'text/javascript';\n                node.setAttribute(\"src\",dep.url);\n                node.setAttribute(\"id\",dep.id);\n\n                (function(node,dep,deferred){\n\n                    node.onload = node.onreadystatechange = function(){\n\n                        //Autoresolve by default\n                        if(typeof deferred.autoresolve !== 'boolean' \n                        || deferred.autoresolve === true){\n                          deferred.resolve((typeof node.value !== 'undefined') ? node.value : node);\n                        }\n                    };\n                    node.onerror = function(){\n                        deferred.reject(\"Error loading: \" + dep.url);\n                    };\n                }(node,dep,deferred));\n\n                this.head.appendChild(node);\n                break;\n\n            case(dep.type==='css' || dep.type==='link'):\n\n                var node = document.createElement(\"link\");\n                node.setAttribute(\"href\",dep.url);\n                node.setAttribute(\"type\",\"text/css\");\n                node.setAttribute(\"rel\",\"stylesheet\");\n\n                if(node.onload){\n                    (function(node,dep,deferred){\n                        node.onload = node.onreadystatechange = function(){\n                           deferred.resolve(node);\n                       };\n\n                       node.onerror = function(){\n                           deferred.reeject(\"Failed to load path: \" + dep.url);\n                       };\n\n                    }(node,dep,deferred));\n\n                    this.head.appendChild(node);\n                    break;\n                }\n                else{\n                    //ADD NODE BUT MAKE XHR REQUEST TO CHECK FILE RECEIVED\n                    this.head.appendChild(node);\n                }\n\n            case(dep.type==='json'):\n            default:\n\n                var r;\n                var req = new XMLHttpRequest();\n                req.open('GET', dep.url, true);\n\n                if(typeof dep.show_messages !== 'undefined'){\n                    req.setRequestHeader('show-messages', dep.show_messages);\n                }\n                if(typeof dep.return_packet !== 'undefined'){\n                    req.setRequestHeader('return-packet', dep.return_packet);\n                }\n\n                (function(dep,deferred){\n                    req.onreadystatechange = function() {\n                        if (req.readyState === 4) {\n                            if(req.status === 200){\n                                r = req.responseText;\n                                if(dep.type === 'json'){\n                                    try{\n                                        r = JSON.parse(r);\n                                    }\n                                    catch(e){\n                                        public.debug([\n                                            \"Could not decode JSON\"\n                                            ,dep.url\n                                            ,r\n                                        ],deferred);\n                                    }\n                                }\n                                //WE WANT TO RESOLVE WITH DOM NODE FOR CSS FILES\n                                deferred.resolve(node || r);\n                            }\n                            else{\n                                deferred.reject(\"Error loading: \" + dep.url);\n                            }\n                        }\n                    };\n                }(dep,deferred));\n\n                req.send(null);\n        }\n    }\n    //NODEJS\n    else{\n        \n        \n      function process_result(deferred,data,dep){\n\n          switch(true){\n\n              case(dep.type === 'json'):\n                  data = JSON.parse(data);\n                  deferred.resolve(data);\n                  break;\n\n              default:\n                  deferred.resolve(data);\n\n          }\n      }     \n\n      if(dep.remote){\n        var request = require('request');\n        request.get(dep.url, function (error, response, body) {\n            if (!error && response.statusCode == 200) {\n                process_result(deferred,body,dep);\n            };\n        });\n      }\n      else{\n        \n        var owd = process.cwd()\n        ,cwd = (deferred.cwd) ? deferred.cwd : \n                  ((private.config.cwd) ? private.config.cwd : false)\n        ,dirchanged = false;\n        \n        if(cwd){\n          process.chdir(cwd);\n          dirchanged = true;\n        }\n        else{\n          cwd = process.cwd();\n        }\n        \n        var path = cwd + \"/\" + dep.url;\n\n        //Get scripts\n        if(dep.type === 'script'){\n\n            var data = require(path);\n\n            //Autoresolve by default\n            if(typeof deferred.autoresolve !== 'boolean' \n            || deferred.autoresolve === true){\n              deferred.resolve(data);\n            }\n        }\n        //DON'T GET CSS, JUST ADD NODE\n        else if(dep.type === 'css'){\n\n          if(private.config.document !== null){\n            var node = private.config.document('head').append('<link rel=\"stylesheet\" href=\"'+dep.url+'\" type=\"text/css\" />');\n            deferred.resolve(node);\n          }\n          else{\n              return public.debug([\n                  dep.url\n                  ,\"Must pass html document to Orgy.config() before attempting to add DOM nodes [i.e. css] as dependencies.\"\n              ],deferred);\n          }\n        }\n        else{\n\n          var fs = require('fs');\n\n          (function(deferred,dep){\n\n                fs.readFile(path, 'utf8', function (err, data) {\n\n                    if (err){\n                        public.debug([\n                            \"File \" + dep.url + \" not found @ local dep.url '\" + dep.url +\"'\"\n                            ,\"CWD: \"+process.cwd()\n                        ],deferred);\n\n                        process.exit();\n                    }\n\n                    process_result(deferred,data,dep);\n                });\n\n            }(deferred,dep));\n\n        }\n        \n        //Change back to saved cwd\n        if(dirchanged){\n          process.chdir(owd);\n        }\n      }\n    }\n\n    return deferred;\n};","/**\n * Default properties for all deferred objects.\n * \n */\n\n//////////////////////////////////////////\n//  PUBLIC VARIABLES\n//////////////////////////////////////////\n\n\n//////////////////////////////////////////\n//  PRIVATE VARIABLES\n//////////////////////////////////////////\n\n\nprivate.deferred.tpl = {};\n\nprivate.deferred.tpl.id = null;\n\n//A COUNTER FOR AUT0-GENERATED PROMISE ID'S\nprivate.deferred.tpl.settled = 0;\n\n/**\n * STATE CODES:\n * ------------------\n * -1   => SETTLING [EXECUTING CALLBACKS]\n *  0   => PENDING\n *  1   => RESOLVED / FULFILLED\n *  2   => REJECTED \n */\nprivate.deferred.tpl.state = 0;\n\nprivate.deferred.tpl.value = [];\n\n//The most recent value generated by the then->done chain. \nprivate.deferred.tpl.caboose = null;\n\nprivate.deferred.tpl.model = \"deferred\";\n\nprivate.deferred.tpl.done_fired = 0;\n\nprivate.deferred.tpl.timeout_id = null;\n\nprivate.deferred.tpl.callback_states = {\n    resolve : 0\n    ,then : 0\n    ,done : 0\n    ,reject : 0\n};\n\n/**\n * Self executing function to initialize callback event\n * list.\n * \n * Returns an object with the same propertyNames as \n * private.deferred.tpl.callback_states: adding boilerplate\n * properties for each\n * \n * @returns {object}\n */\nprivate.deferred.tpl.callbacks = (function(){\n    \n    var o = {};\n    \n    for(var i in private.deferred.tpl.callback_states){\n        o[i] = {\n            train : []\n            ,hooks : {\n                onBefore : {\n                    train : []\n                }\n                ,onComplete : {\n                    train : []\n                }\n            }\n        };\n    }\n    \n    return o;\n})();\n    \n//PROMISE HAS OBSERVERS BUT DOES NOT OBSERVE OTHERS\nprivate.deferred.tpl.downstream = {};\n\nprivate.deferred.tpl.execution_history = [];\n\n//WHEN TRUE, ALLOWS RE-INIT [FOR UPGRADES TO A QUEUE]          \nprivate.deferred.tpl.overwritable = 0; \n\n\n/**\n * Default timeout for a deferred\n * @type number\n */\nprivate.deferred.tpl.timeout = private.config.timeout;\n\n/**\n * REMOTE\n * \n * REMOTE == 1  =>  [DEFAULT] Make http request for file\n * \n * REMOTE == 0  =>  Read file directly from the filesystem\n * \n * ONLY APPLIES TO SCRIPTS RUN UNDER NODE AS BROWSER HAS NO \n * FILESYSTEM ACCESS\n */\nprivate.deferred.tpl.remote = 1;\n\n//ADDS TO MASTER LIST. ALWAYS TRUE UNLESS UPGRADING A PROMISE TO A QUEUE\nprivate.deferred.tpl.list = 1;\n\n\n//////////////////////////////////////////\n//  PUBLIC METHODS\n//////////////////////////////////////////\n\n\n/**\n * Resolves a deferred.\n * \n * @param {mixed} value\n * @returns {void}\n */\nprivate.deferred.tpl.resolve = function(value){\n\n    if(this.settled === 1){\n        public.debug([\n            this.id + \" can't resolve.\"\n            ,\"Only unsettled deferreds are resolvable.\"\n        ]);\n    }\n\n    //SET STATE TO SETTLEMENT IN PROGRESS\n    private.deferred.set_state(this,-1);\n\n    //SET VALUE\n    this.value = value;\n\n    //RUN RESOLVER BEFORE PROCEEDING\n    //EVEN IF THERE IS NO RESOLVER, SET IT TO FIRED WHEN CALLED\n    if(!this.resolver_fired && typeof this.resolver === 'function'){\n        \n        this.resolver_fired = 1;   \n        \n        //Add resolver to resolve train\n        try{\n          this.callbacks.resolve.train.push(function(){\n              this.resolver(value,this);\n          });\n        }\n        catch(e){\n          debugger;\n        }\n    }\n    else{\n        \n        this.resolver_fired = 1;  \n        \n        //Add settle to resolve train\n        //Always settle before all other complete callbacks\n        this.callbacks.resolve.hooks.onComplete.train.unshift(function(){\n            private.deferred.settle(this);\n        });\n    }\n\n    //Run resolve\n    private.deferred.run_train(\n        this\n        ,this.callbacks.resolve\n        ,this.value\n        ,{pause_on_deferred : false}\n    );\n\n    //resolver is expected to call resolve again\n    //and that will get us past this point\n    return this;\n};\n\n\nprivate.deferred.tpl.reject = function(err){\n\n    if(!(err instanceof Array)){\n        err = [err];\n    }\n\n    var msg = \"Rejected \"+this.model+\": '\"+this.id+\"'.\"\n    \n    if(private.config.debug_mode){\n      err.unshift(msg);\n      public.debug(err,this);\n    }\n    else{\n      msg = msg + \"\\n Turn debug mode on for more info.\";\n      console.log(msg);\n    }\n\n    //Remove auto timeout timer\n    if(this.timeout_id){\n        clearTimeout(this.timeout_id);\n    }\n\n    //Set state to rejected\n    private.deferred.set_state(this,2);\n\n    //Execute rejection queue\n    private.deferred.run_train(\n        this\n        ,this.callbacks.reject\n        ,err\n        ,{pause_on_deferred : false}\n    );\n\n    return this;\n};\n\n\nprivate.deferred.tpl.then = function(fn,rejector){\n\n    switch(true){\n\n        //An error was previously thrown, bail out\n        case(this.state === 2):\n            break;\n\n        //Execution chain already finished. Bail out.\n        case(this.done_fired === 1):\n            return public.debug(this.id+\" can't attach .then() because .done() has already fired, and that means the execution chain is complete.\");\n\n        default:\n\n            //Push callback to then queue\n            this.callbacks.then.train.push(fn);\n\n            //Push reject callback to the rejection queue\n            if(typeof rejector === 'function'){\n                this.callbacks.reject.train.push(rejector);\n            }\n            \n            //Settled, run train now\n            if(this.settled === 1 && this.state === 1 && !this.done_fired){        \n                private.deferred.run_train(\n                    this\n                    ,this.callbacks.then\n                    ,this.caboose\n                    ,{pause_on_deferred : true}\n                );\n            }\n            //Unsettled, train will be run when settled\n            else{}\n    }\n\n    return this;\n};\n\n\nprivate.deferred.tpl.done = function(fn,rejector){\n\n    if(this.callbacks.done.train.length === 0\n       && this.done_fired === 0){\n        if(typeof fn === 'function'){\n            \n            //wrap callback with some other commands\n            var fn2 = function(r,deferred,last){\n              \n                //Done can only be called once, so note that it has been\n                deferred.done_fired = 1;\n                \n                fn(r,deferred,last);\n            };\n\n            this.callbacks.done.train.push(fn2);\n            \n            //Push reject callback to the rejection queue onComplete\n            if(typeof rejector === 'function'){\n                this.callbacks.reject.hooks.onComplete.train.push(rejector);\n            }\n            \n            //Settled, run train now\n            if(this.settled === 1){\n              if(this.state === 1){     \n                private.deferred.run_train(\n                    this\n                    ,this.callbacks.done\n                    ,this.caboose\n                    ,{pause_on_deferred : false}\n                );\n              }\n              else{\n                private.deferred.run_train(\n                    this\n                    ,this.callbacks.reject\n                    ,this.caboose\n                    ,{pause_on_deferred : false}\n                );\n              }\n            }\n            //Unsettled, train will be run when settled\n            else{}\n        }\n        else{\n            return public.debug(\"done() must be passed a function.\");\n        }\n    }\n    else{\n        return public.debug(\"done() can only be called once.\");\n    }\n};","public.queue = {};\nprivate.queue = {};\n\n\n//////////////////////////////////////////\n//  PUBLIC VARIABLES\n//////////////////////////////////////////\n\n\n//////////////////////////////////////////\n//  PRIVATE VARIABLES\n//////////////////////////////////////////\n\n\n/**\n* Template object for all queues\n* \n* @type object\n*/\nprivate.queue.tpl = {\n\n   model : 'queue'\n\n\n   //SET TRUE AFTER RESOLVER FIRED\n   ,resolver_fired : 0\n\n\n   //PREVENTS A QUEUE FROM RESOLVING EVEN IF ALL DEPENDENCIES MET\n   //PURPOSE: PREVENTS QUEUES CREATED BY ASSIGNMENT FROM RESOLVING \n   //BEFORE THEY ARE FORMALLY INSTANTIATED\n   ,halt_resolution : 0\n\n\n   //USED TO CHECK STATE, ENSURES ONE COPY\n   ,upstream : {}\n\n\n   //USED RETURN VALUES, ENSURES ORDER\n   ,dependencies : []\n\n\n   ///////////////////////////////////////////////////\n   //  QUEUE INSTANCE METHODS\n   ///////////////////////////////////////////////////\n\n\n   /**\n    * Add list of dependencies to a queue's upstream array.\n    * \n    * The queue will resolve once all the promises in its \n    * upstream array are resolved.\n    * \n    * When public.config.debug == 1, method will test each \n    * dependency is not previously scheduled to resolve \n    * downstream from the target, in which \n    * case it would never resolve because its upstream depends on it.\n    * \n    * @param {array} arr  /array of dependencies to add\n    * @returns {array} upstream\n    */\n   ,add : function(arr){\n\n       try{\n           if(arr.length === 0) return this.upstream;\n       }\n       catch(err){\n           public.debug(err);\n       }\n\n       //IF NOT PENDING, DO NOT ALLOW TO ADD\n       if(this.state !== 0){\n           return public.debug(\"Cannot add list to queue id:'\"+this.id\n           +\"'. Queue settled/in the process of being settled.\",this);\n       }\n\n       for(var a in arr){\n\n           switch(true){\n\n               //CHECK IF EXISTING PROMISE\n               case(typeof public.list[arr[a]['id']] === 'object'):\n                   arr[a] = public.list[arr[a]['id']];\n                   break;\n\n               //IF NOT, ATTEMPT TO CONVERT IT TO A PROMISE\n               case(typeof arr[a] === 'object' && typeof arr[a].then !== 'function'):\n                   arr[a] = private.deferred.convert_to_promise(this,arr[a]);\n                   break;\n\n               //REF IS A PROMISE.\n               case(typeof arr[a].then === 'function'):\n                   break;\n\n               default:\n                   console.error(\"Object could not be converted to promise.\");\n                   console.error(arr[a]);\n                   debugger;\n                   continue;\n           }\n\n           //must check the target to see if the dependency exists in its downstream\n           for(var b in this.downstream){\n               if(b === arr[a].id){\n                   return public.debug(\"Error adding upstream dependency '\"+arr[a].id+\"' to queue\"+\" '\"+this.id+\"'.\\n Promise object for '\"+arr[a].id+\"' is scheduled to resolve downstream from queue '\"+this.id+\"' so it can't be added upstream.\");\n               }\n           }\n\n           //ADD TO UPSTREAM, DOWNSTREAM, DEPENDENCIES\n           this.upstream[arr[a].id] = arr[a];\n           arr[a].downstream[this.id] = this;\n           this.dependencies.push(arr[a]);\n       }\n\n       return this.upstream;\n   }\n\n\n   /**\n    * Remove list from a queue.\n    * \n    * @param {array} arr\n    * @returns {array} array of list the queue is upstream\n    */\n   ,remove : function(arr){\n\n      //IF NOT PENDING, DO NOT ALLOW REMOVAL\n      if(this.state !== 0){\n          return public.debug(\"Cannot remove list from queue id:'\"+this.id+\"'. Queue settled/in the process of being settled.\");\n      }\n\n      for(var a in arr){\n         if(this.upstream[arr[a].id]){\n            delete this.upstream[arr[a].id];\n            delete arr[a].downstream[this.id];\n         }\n      }\n   }\n\n\n  /**\n   * Resets an existing,settled queue back to Orgying state.\n   * Clears out the downstream.\n   * Fails if not settled.\n   * @param {object} options\n   * @returns {private.queue.tpl|Boolean}\n   */\n   ,reset : function(options){\n\n      if(this.settled !== 1 || this.state !== 1){\n        return public.debug(\"Can only reset a queue settled without errors.\");\n      }\n\n      options = options || {};\n\n      this.settled = 0;\n      this.state = 0; \n      this.resolver_fired = 0;\n      this.done_fired = 0;\n\n      //REMOVE AUTO TIMEOUT TIMER\n      if(this.timeout_id){\n        clearTimeout(this.timeout_id);\n      }\n\n      //CLEAR OUT THE DOWNSTREAM\n      this.downstream = {};\n      this.dependencies = [];\n\n      //SET NEW AUTO TIMEOUT\n      private.deferred.auto_timeout.call(this,options.timeout);\n\n      //POINTLESS - WILL JUST IMMEDIATELY RESOLVE SELF\n      //this.check_self()\n\n      return this;\n   }\n\n\n   /**\n    * Cauaes a queue to look over its dependencies and see if it \n    * can be resolved.\n    * \n    * This is done automatically by each dependency that loads,\n    * so is not needed unless:\n    * \n    * -debugging\n    * \n    * -the queue has been reset and no new\n    * dependencies were since added.\n    * \n    * @returns {int} State of the queue.\n    */\n   ,check_self : function(){\n      private.queue.receive_signal(this,this.id);\n      return this.state;\n   }\n};\n\n\n//////////////////////////////////////////\n//  PUBLIC METHODS\n//////////////////////////////////////////\n\n\n/**\n * Creates a new queue object.\n * \n * @param {array} deps\n * @param {object} options\n *          {string}  id  /Optional. Use the id with Orgy.get(id). Defaults to line number of instantiation, plus an iterator.\n *          {callback(result,deferred)} resolver /Callback function to execute after all dependencies have resolved. Arg1 is an array of the dependencies' resolved values. Arg2 is the deferred object. The queue will only resolve when Arg2.resolve() is called. If not, it will timeout to options.timeout || Orgy.config.timeout. \n *          {number} timeout /time in ms after which reject is called. Defaults to Orgy.config().timeout [5000]. Note the timeout is only affected by dependencies and/or the resolver callback. Then,done delays will not flag a timeout because they are called after the instance is considered resolved.\n *          \n * @returns {object}\n */\npublic.queue = function(deps,options){\n\n    var _o;\n    if(!(deps instanceof Array)){\n      return public.debug(\"Queue dependencies must be an array.\");\n    }\n    \n    options = options || {};\n    \n    //DOES NOT ALREADY EXIST\n    if(!public.list[options.id]){\n        \n      //CREATE NEW QUEUE OBJECT\n      var _o = private.queue.factory(options);\n\n      //ACTIVATE QUEUE\n      _o = private.queue.activate(_o,options,deps);\n\n    }\n    //ALREADY EXISTS\n    else {\n        \n      _o = public.list[options.id];\n\n      if(_o.model !== 'queue'){\n      //MATCH FOUND BUT NOT A QUEUE, UPGRADE TO ONE\n\n        options.overwritable = 1;\n\n        _o = private.queue.upgrade(_o,options,deps);\n      }\n      else{\n\n        //OVERWRITE ANY EXISTING OPTIONS\n        for(var i in options){\n            _o[i] = options[i];\n        }\n\n        //ADD ADDITIONAL DEPENDENCIES IF NOT RESOLVED\n        if(deps.length > 0){\n            private.queue.tpl.add.call(_o,deps);\n        }\n\n      }\n\n      //RESUME RESOLUTION UNLESS SPECIFIED OTHERWISE\n      _o.halt_resolution = (typeof options.halt_resolution !== 'undefined') ?\n      options.halt_resolution : 0;\n    }\n    \n    return _o;\n};\n\n\n//////////////////////////////////////////\n//  PRIVATE METHODS\n//////////////////////////////////////////\n\n\nprivate.queue.factory = function(options){\n\n  //CREATE A NEW QUEUE OBJECT\n  var _o = public.naive_cloner([\n    private.deferred.tpl\n    ,private.queue.tpl\n    ,options\n  ]);\n\n  //Get backtrace info if none found [may be set @ public.define]\n  if(!_o.backtrace){\n    _o.backtrace = private.get_backtrace_info('public.queue');\n  }\n\n  //if no id, use backtrace origin\n  if(!options.id){\n    _o.id = _o.backtrace.origin + '-' + (++public.i);\n  }\n\n  return _o;\n};    \n    \n    \n/**\n * Activates a queue object.\n * \n * @param {object} o\n * @param {object} options\n * @param {array} deps\n * @returns {object} queue\n */\nprivate.queue.activate = function(o,options,deps){\n\n    //ACTIVATE AS A DEFERRED\n    o = private.deferred.activate(o);\n    \n    //ADD DEPENDENCIES TO QUEUE\n    private.queue.tpl.add.call(o,deps);\n\n    //SEE IF CAN BE IMMEDIATELY RESOLVED BY CHECKING UPSTREAM\n    private.queue.receive_signal(o,o.id);\n\n    //ASSIGN THIS QUEUE UPSTREAM TO OTHER QUEUES\n    if(o.assign){\n        for(var a in o.assign){\n            public.assign(o.assign[a],[o],true);\n        }\n    }\n\n    return o;\n};\n    \n    \n/**\n* A \"signal\" here causes a queue to look through each item \n* in its upstream and check to see if all are resolved. \n* \n* Signals can only be received by a queue itself or an instance\n* in its upstream.\n* \n* @param {object} target\n* @param {string} from_id\n* @returns {void}\n*/\nprivate.queue.receive_signal = function(target,from_id){\n\n    if(target.halt_resolution === 1) return;\n\n   //MAKE SURE THE SIGNAL WAS FROM A PROMISE BEING LISTENED TO\n   //BUT ALLOW SELF STATUS CHECK\n   if(from_id !== target.id && !target.upstream[from_id]){\n       return public.debug(from_id + \" can't signal \" + target.id + \" because not in upstream.\");\n   }\n   //RUN THROUGH QUEUE OF OBSERVING PROMISES TO SEE IF ALL DONE\n   else{\n       var status = 1;\n       for(var i in target.upstream){\n           //SETS STATUS TO 0 IF ANY OBSERVING HAVE FAILED, BUT NOT IF PENDING OR RESOLVED\n           if(target.upstream[i].state !== 1) {\n               status = target.upstream[i].state;\n               break;\n           }\n       }\n   }\n\n   //RESOLVE QUEUE IF UPSTREAM FINISHED\n   if(status === 1){\n\n        //GET RETURN VALUES PER DEPENDENCIES, WHICH SAVES ORDER AND \n        //REPORTS DUPLICATES\n        var values = [];\n        for(var i in target.dependencies){\n            values.push(target.dependencies[i].value);\n        }\n\n        private.deferred.tpl.resolve.call(target,values);\n   }\n\n   if(status === 2){\n       var err = [\n           target.id+\" dependency '\"+target.upstream[i].id + \"' was rejected.\"\n           ,target.upstream[i].arguments\n       ];\n       private.deferred.tpl.reject.apply(target,err);\n   }\n};\n\n\n/**\n* Upgrades a promise object to a queue.\n* \n* @param {object} obj\n* @param {object} options\n* @param {array} deps \\dependencies\n* @returns {object} queue object\n*/\nprivate.queue.upgrade = function(obj,options,deps){\n\n    if(obj.settled !== 0 || (obj.model !== 'promise' && obj.model !== 'deferred')){\n        return public.debug('Can only upgrade unsettled promise or deferred into a queue.');\n    }\n\n   //GET A NEW QUEUE OBJECT AND MERGE IN\n    var _o = public.naive_cloner([\n        private.queue.tpl\n        ,options\n    ]);\n\n    for(var i in _o){\n       obj[i] = _o[i];\n    }\n\n    delete _o;\n\n    //CREATE NEW INSTANCE OF QUEUE\n    obj = private.queue.activate(obj,options,deps);\n\n    //RETURN QUEUE OBJECT\n    return obj;\n};","////////////////////////////////////////\n//  PUBLIC METHODS\n////////////////////////////////////////\n\n\n/**\n * Casts an object into an Orgy deferred.\n * \n * > Object to be casted must have the following properties:\n *  - then()\n *  - error() \n * \n * > If the casted object has an id or url property set, the id or url\n * [in that order] will become the id of the deferred for referencing\n * with Orgy.get(id)\n *  \n * @param {object} obj  /thenable\n * @returns {object}\n */\npublic.cast = function(obj){\n            \n    var required = [\"then\",\"error\"];\n    for(var i in required){\n        if(!obj[required[i]]){\n            return public.debug(\"Castable objects require: \" \n                + required[i]);\n        }\n    }\n\n    var options = {};\n    if(obj.id){\n        options.id = obj.id;\n    }\n    else if(obj.url){\n        options.id = obj.url;\n    }\n\n    //Create a deferred\n    var def = public.deferred(options);\n\n    //Create resolver\n    var resolver = function(){\n        def.resolve.call(def,arguments[0]);\n    };\n\n    //Set Resolver\n    obj.then(resolver);\n\n    //Create Rejector\n    var err = function(err){\n      def.reject(err);\n    };\n\n    //Set rejector\n    obj.error(err);\n\n    //Return deferred\n    return def;\n};      ","if(typeof process === 'object' && process + '' === '[object process]'){\n    // is node\n    module.exports = public;\n}\nelse{\n    // not node\n    Orgy = public;\n}"]}